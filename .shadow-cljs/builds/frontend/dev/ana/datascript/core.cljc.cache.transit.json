["^ ","~:output",["^ ","~:js","goog.provide('datascript.core');\ndatascript.core.tx0 = (536870912);\n/**\n * Retrieves an entity by its id from database. Entities are lazy map-like structures to navigate DataScript database content.\n * \n *           For `eid` pass entity id or lookup attr:\n *           \n *               (entity db 1)\n *               (entity db [:unique-attr :value])\n *          \n *           If entity does not exist, `nil` is returned:\n * \n *               (entity db 100500) ; => nil\n * \n *           Creating an entity by id is very cheap, almost no-op, as attr access is on-demand:\n * \n *               (entity db 1) ; => {:db/id 1}\n * \n *           Entity attributes can be lazily accessed through key lookups:\n *           \n *               (:attr (entity db 1)) ; => :value\n *               (get (entity db 1) :attr) ; => :value\n * \n *           Cardinality many attributes are returned sequences:\n * \n *               (:attrs (entity db 1)) ; => [:v1 :v2 :v3]\n * \n *           Reference attributes are returned as another entities:\n * \n *               (:ref (entity db 1)) ; => {:db/id 2}\n *               (:ns/ref (entity db 1)) ; => {:db/id 2}\n * \n *           References can be walked backwards by prepending `_` to name part of an attribute:\n * \n *               (:_ref (entity db 2)) ; => [{:db/id 1}]\n *               (:ns/_ref (entity db 2)) ; => [{:db/id 1}]\n *           \n *           Reverse reference lookup returns sequence of entities unless attribute is marked as `:db/isComponent`:\n * \n *               (:_component-ref (entity db 2)) ; => {:db/id 1}\n * \n *           Entity gotchas:\n *             \n *           - Entities print as map, but are not exactly maps (they have compatible get interface though).\n *           - Entities are effectively immutable “views” into a particular version of a database.\n *           - Entities retain reference to the whole database.\n *           - You can’t change database through entities, only read.\n *           - Creating an entity by id is very cheap, almost no-op (attributes are looked up on demand).\n *           - Comparing entities just compares their ids. Be careful when comparing entities taken from different dbs or from different versions of the same db.\n *           - Accessed entity attributes are cached on entity itself (except backward references).\n *           - When printing, only cached attributes (the ones you have accessed before) are printed. See [[touch]].\n */\ndatascript.core.entity = datascript.impl.entity.entity;\n/**\n * Given lookup ref `[unique-attr value]`, returns numberic entity id.\n * \n *           If entity does not exist, returns `nil`.\n */\ndatascript.core.entid = datascript.db.entid;\n/**\n * Returns a db that entity was created from.\n */\ndatascript.core.entity_db = (function datascript$core$entity_db(entity){\nif(datascript.impl.entity.entity_QMARK_(entity)){\n} else {\nthrow (new Error(\"Assert failed: (de/entity? entity)\"));\n}\n\nreturn entity.db;\n});\n/**\n * Forces all entity attributes to be eagerly fetched and cached. Only usable for debug output.\n * \n *           Usage:\n * \n *           ```\n *           (entity db 1) ; => {:db/id 1}\n *           (touch (entity db 1)) ; => {:db/id 1, :dislikes [:pie], :likes [:pizza]}\n *           ```\n */\ndatascript.core.touch = datascript.impl.entity.touch;\n/**\n * Fetches data from database using recursive declarative description. See [docs.datomic.com/on-prem/pull.html](https://docs.datomic.com/on-prem/pull.html).\n * \n *           Unlike [[entity]], returns plain Clojure map (not lazy).\n * \n *           Usage:\n * \n *               (pull db [:db/id, :name, :likes, {:friends [:db/id :name]}] 1)\n *               ; => {:db/id   1,\n *               ;     :name    \"Ivan\"\n *               ;     :likes   [:pizza]\n *               ;     :friends [{:db/id 2, :name \"Oleg\"}]}\n */\ndatascript.core.pull = datascript.pull_api.pull;\n/**\n * Same as [[pull]], but accepts sequence of ids and returns sequence of maps.\n * \n *           Usage:\n * \n *           ```\n *           (pull-many db [:db/id :name] [1 2])\n *           ; => [{:db/id 1, :name \"Ivan\"}\n *           ;     {:db/id 2, :name \"Oleg\"}]\n *           ```\n */\ndatascript.core.pull_many = datascript.pull_api.pull_many;\n/**\n * Executes a datalog query. See [docs.datomic.com/on-prem/query.html](https://docs.datomic.com/on-prem/query.html).\n * \n *        Usage:\n *        \n *        ```\n *        (q '[:find ?value\n *             :where [_ :likes ?value]]\n *           db)\n *        ; => #{[\"fries\"] [\"candy\"] [\"pie\"] [\"pizza\"]}\n *        ```\n */\ndatascript.core.q = datascript.query.q;\ndatascript.core.maybe_adapt_storage = (function datascript$core$maybe_adapt_storage(opts){\nreturn opts;\n});\n/**\n * Creates an empty database with an optional schema.\n * \n * Usage:\n * \n * ```\n * (empty-db) ; => #datascript/DB {:schema {}, :datoms []}\n * \n * (empty-db {:likes {:db/cardinality :db.cardinality/many}})\n * ; => #datascript/DB {:schema {:likes {:db/cardinality :db.cardinality/many}}\n * ;                    :datoms []}\n * ```\n * \n * Options are:\n * \n * :branching-factor <int>, default 512. B-tree max node length\n * :ref-type         :strong | :soft | :weak, default :soft. How will nodes that are already\n *                   stored on disk be referenced. Soft or weak means they might be unloaded\n *                   from memory under memory pressure and later fetched from storage again.\n * :storage          <IStorage>. Will be used to store this db later with `(d/store db)`\n */\ndatascript.core.empty_db = (function datascript$core$empty_db(var_args){\nvar G__23678 = arguments.length;\nswitch (G__23678) {\ncase 0:\nreturn datascript.core.empty_db.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn datascript.core.empty_db.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn datascript.core.empty_db.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.empty_db.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn datascript.db.empty_db(null,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(datascript.core.empty_db.cljs$core$IFn$_invoke$arity$1 = (function (schema){\nreturn datascript.db.empty_db(schema,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(datascript.core.empty_db.cljs$core$IFn$_invoke$arity$2 = (function (schema,opts){\nreturn datascript.db.empty_db(schema,datascript.core.maybe_adapt_storage(opts));\n}));\n\n(datascript.core.empty_db.cljs$lang$maxFixedArity = 2);\n\n/**\n * Returns `true` if the given value is an immutable database, `false` otherwise.\n */\ndatascript.core.db_QMARK_ = datascript.db.db_QMARK_;\n/**\n * Low-level fn to create raw datoms.\n * \n *           Optionally with transaction id (number) and `added` flag (`true` for addition, `false` for retraction).\n * \n *           See also [[init-db]].\n */\ndatascript.core.datom = datascript.db.datom;\n/**\n * Returns `true` if the given value is a datom, `false` otherwise.\n */\ndatascript.core.datom_QMARK_ = datascript.db.datom_QMARK_;\n/**\n * Low-level fn for creating database quickly from a trusted sequence of datoms.\n * Does no validation on inputs, so `datoms` must be well-formed and match schema.\n * Used internally in db (de)serialization. See also [[datom]].\n * For options, see [[empty-db]]\n */\ndatascript.core.init_db = (function datascript$core$init_db(var_args){\nvar G__23681 = arguments.length;\nswitch (G__23681) {\ncase 1:\nreturn datascript.core.init_db.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn datascript.core.init_db.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.init_db.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.init_db.cljs$core$IFn$_invoke$arity$1 = (function (datoms){\nreturn datascript.db.init_db(datoms,null,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(datascript.core.init_db.cljs$core$IFn$_invoke$arity$2 = (function (datoms,schema){\nreturn datascript.db.init_db(datoms,schema,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(datascript.core.init_db.cljs$core$IFn$_invoke$arity$3 = (function (datoms,schema,opts){\nreturn datascript.db.init_db(datoms,schema,datascript.core.maybe_adapt_storage(opts));\n}));\n\n(datascript.core.init_db.cljs$lang$maxFixedArity = 3);\n\n/**\n * Converts db into a data structure (not string!) that can be fed to serializer\n *           of your choice (e.g. `js/JSON.stringify` in CLJS, `cheshire.core/generate-string`\n *           or `jsonista.core/write-value-as-string` in CLJ).\n * \n *           On JVM, `serializable` holds a global lock that prevents any two serializations\n *           to run in parallel (an implementation constraint, be aware).\n * \n *           Options:\n * \n *           `:freeze-fn` Non-primitive values will be serialized using this. Optional.\n *           `pr-str` by default.\n */\ndatascript.core.serializable = datascript.serialize.serializable;\n/**\n * Creates db from a data structure (not string!) produced by serializable.\n * \n *           Opts:\n * \n *           `:thaw-fn` Non-primitive values will be deserialized using this.\n *           Must match :freeze-fn from serializable. Optional. `clojure.edn/read-string`\n *           by default.\n */\ndatascript.core.from_serializable = datascript.serialize.from_serializable;\n/**\n * Returns a schema of a database.\n */\ndatascript.core.schema = datascript.db._schema;\n/**\n * Returns `true` if this database was filtered using [[filter]], `false` otherwise.\n */\ndatascript.core.is_filtered = (function datascript$core$is_filtered(x){\nreturn (x instanceof datascript.db.FilteredDB);\n});\n/**\n * Returns a view over database that has same interface but only includes datoms for which the `(pred db datom)` is true. Can be applied multiple times.\n * \n * Filtered DB gotchas:\n * \n * - All operations on filtered database are proxied to original DB, then filter pred is applied.\n * - Not cached. You pay filter penalty every time.\n * - Supports entities, pull, queries, index access.\n * - Does not support [[with]] and [[db-with]].\n */\ndatascript.core.filter = (function datascript$core$filter(db,pred){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nif(datascript.core.is_filtered(db)){\nvar fdb = db;\nvar orig_pred = fdb.pred;\nvar orig_db = fdb.unfiltered_db;\nreturn (new datascript.db.FilteredDB(orig_db,(function (p1__23683_SHARP_){\nvar and__5043__auto__ = (orig_pred.cljs$core$IFn$_invoke$arity$1 ? orig_pred.cljs$core$IFn$_invoke$arity$1(p1__23683_SHARP_) : orig_pred.call(null,p1__23683_SHARP_));\nif(cljs.core.truth_(and__5043__auto__)){\nreturn (pred.cljs$core$IFn$_invoke$arity$2 ? pred.cljs$core$IFn$_invoke$arity$2(orig_db,p1__23683_SHARP_) : pred.call(null,orig_db,p1__23683_SHARP_));\n} else {\nreturn and__5043__auto__;\n}\n}),cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0)),null,null,null));\n} else {\nreturn (new datascript.db.FilteredDB(db,(function (p1__23684_SHARP_){\nreturn (pred.cljs$core$IFn$_invoke$arity$2 ? pred.cljs$core$IFn$_invoke$arity$2(db,p1__23684_SHARP_) : pred.call(null,db,p1__23684_SHARP_));\n}),cljs.core.atom.cljs$core$IFn$_invoke$arity$1((0)),null,null,null));\n}\n});\n/**\n * Same as [[transact!]], but applies to an immutable database value. Returns transaction report (see [[transact!]]).\n */\ndatascript.core.with$ = (function datascript$core$with(var_args){\nvar G__23686 = arguments.length;\nswitch (G__23686) {\ncase 2:\nreturn datascript.core.with$.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.with$.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.with$.cljs$core$IFn$_invoke$arity$2 = (function (db,tx_data){\nreturn datascript.core.with$.cljs$core$IFn$_invoke$arity$3(db,tx_data,null);\n}));\n\n(datascript.core.with$.cljs$core$IFn$_invoke$arity$3 = (function (db,tx_data,tx_meta){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nif(datascript.core.is_filtered(db)){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"Filtered DB cannot be modified\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"error\",\"error\",-978969032),new cljs.core.Keyword(\"transaction\",\"filtered\",\"transaction/filtered\",1699706605)], null));\n} else {\nreturn datascript.db.transact_tx_data(datascript.db.__GT_TxReport(db,db,cljs.core.PersistentVector.EMPTY,cljs.core.PersistentArrayMap.EMPTY,tx_meta),tx_data);\n}\n}));\n\n(datascript.core.with$.cljs$lang$maxFixedArity = 3);\n\n/**\n * Applies transaction to an immutable db value, returning new immutable db value. Same as `(:db-after (with db tx-data))`.\n */\ndatascript.core.db_with = (function datascript$core$db_with(db,tx_data){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn new cljs.core.Keyword(null,\"db-after\",\"db-after\",-571884666).cljs$core$IFn$_invoke$arity$1(datascript.core.with$.cljs$core$IFn$_invoke$arity$2(db,tx_data));\n});\n/**\n * Warning! No validation or conversion. Only change schema in a compatible way\n */\ndatascript.core.with_schema = (function datascript$core$with_schema(db,schema){\nreturn datascript.db.with_schema(db,schema);\n});\n/**\n * Index lookup. Returns a sequence of datoms (lazy iterator over actual DB index) which components (e, a, v) match passed arguments.\n * \n * Datoms are sorted in index sort order. Possible `index` values are: `:eavt`, `:aevt`, `:avet`.\n * \n * Usage:\n * \n *     ; find all datoms for entity id == 1 (any attrs and values)\n *     ; sort by attribute, then value\n *     (datoms db :eavt 1)\n *     ; => (#datascript/Datom [1 :friends 2]\n *     ;     #datascript/Datom [1 :likes \"fries\"]\n *     ;     #datascript/Datom [1 :likes \"pizza\"]\n *     ;     #datascript/Datom [1 :name \"Ivan\"])\n *   \n *     ; find all datoms for entity id == 1 and attribute == :likes (any values)\n *     ; sorted by value\n *     (datoms db :eavt 1 :likes)\n *     ; => (#datascript/Datom [1 :likes \"fries\"]\n *     ;     #datascript/Datom [1 :likes \"pizza\"])\n *     \n *     ; find all datoms for entity id == 1, attribute == :likes and value == \"pizza\"\n *     (datoms db :eavt 1 :likes \"pizza\")\n *     ; => (#datascript/Datom [1 :likes \"pizza\"])\n *   \n *     ; find all datoms for attribute == :likes (any entity ids and values)\n *     ; sorted by entity id, then value\n *     (datoms db :aevt :likes)\n *     ; => (#datascript/Datom [1 :likes \"fries\"]\n *     ;     #datascript/Datom [1 :likes \"pizza\"]\n *     ;     #datascript/Datom [2 :likes \"candy\"]\n *     ;     #datascript/Datom [2 :likes \"pie\"]\n *     ;     #datascript/Datom [2 :likes \"pizza\"])\n *   \n *     ; find all datoms that have attribute == `:likes` and value == `\"pizza\"` (any entity id)\n *     ; `:likes` must be a unique attr, reference or marked as `:db/index true`\n *     (datoms db :avet :likes \"pizza\")\n *     ; => (#datascript/Datom [1 :likes \"pizza\"]\n *     ;     #datascript/Datom [2 :likes \"pizza\"])\n *   \n *     ; find all datoms sorted by entity id, then attribute, then value\n *     (datoms db :eavt) ; => (...)\n * \n * Useful patterns:\n * \n *     ; get all values of :db.cardinality/many attribute\n *     (->> (datoms db :eavt eid attr) (map :v))\n *   \n *     ; lookup entity ids by attribute value\n *     (->> (datoms db :avet attr value) (map :e))\n *   \n *     ; find all entities with a specific attribute\n *     (->> (datoms db :aevt attr) (map :e))\n *   \n *     ; find “singleton” entity by its attr\n *     (->> (datoms db :aevt attr) first :e)\n *   \n *     ; find N entities with lowest attr value (e.g. 10 earliest posts)\n *     (->> (datoms db :avet attr) (take N))\n *   \n *     ; find N entities with highest attr value (e.g. 10 latest posts)\n *     (->> (datoms db :avet attr) (reverse) (take N))\n * \n * Gotchas:\n * \n * - Index lookup is usually more efficient than doing a query with a single clause.\n * - Resulting iterator is calculated in constant time and small constant memory overhead.\n * - Iterator supports efficient `first`, `next`, `reverse`, `seq` and is itself a sequence.\n * - Will not return datoms that are not part of the index (e.g. attributes with no `:db/index` in schema when querying `:avet` index).\n *   - `:eavt` and `:aevt` contain all datoms.\n *   - `:avet` only contains datoms for references, `:db/unique` and `:db/index` attributes.\n */\ndatascript.core.datoms = (function datascript$core$datoms(var_args){\nvar G__23696 = arguments.length;\nswitch (G__23696) {\ncase 2:\nreturn datascript.core.datoms.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.datoms.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn datascript.core.datoms.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn datascript.core.datoms.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn datascript.core.datoms.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.datoms.cljs$core$IFn$_invoke$arity$2 = (function (db,index){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._datoms(db,index,null,null,null,null);\n}));\n\n(datascript.core.datoms.cljs$core$IFn$_invoke$arity$3 = (function (db,index,c0){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._datoms(db,index,c0,null,null,null);\n}));\n\n(datascript.core.datoms.cljs$core$IFn$_invoke$arity$4 = (function (db,index,c0,c1){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._datoms(db,index,c0,c1,null,null);\n}));\n\n(datascript.core.datoms.cljs$core$IFn$_invoke$arity$5 = (function (db,index,c0,c1,c2){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._datoms(db,index,c0,c1,c2,null);\n}));\n\n(datascript.core.datoms.cljs$core$IFn$_invoke$arity$6 = (function (db,index,c0,c1,c2,c3){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._datoms(db,index,c0,c1,c2,c3);\n}));\n\n(datascript.core.datoms.cljs$lang$maxFixedArity = 6);\n\n/**\n * Same as [[datoms]], but only returns single datom. Faster than `(first (datoms ...))`\n */\ndatascript.core.find_datom = (function datascript$core$find_datom(var_args){\nvar G__23704 = arguments.length;\nswitch (G__23704) {\ncase 2:\nreturn datascript.core.find_datom.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.find_datom.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn datascript.core.find_datom.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn datascript.core.find_datom.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn datascript.core.find_datom.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.find_datom.cljs$core$IFn$_invoke$arity$2 = (function (db,index){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db.find_datom(db,index,null,null,null,null);\n}));\n\n(datascript.core.find_datom.cljs$core$IFn$_invoke$arity$3 = (function (db,index,c0){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db.find_datom(db,index,c0,null,null,null);\n}));\n\n(datascript.core.find_datom.cljs$core$IFn$_invoke$arity$4 = (function (db,index,c0,c1){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db.find_datom(db,index,c0,c1,null,null);\n}));\n\n(datascript.core.find_datom.cljs$core$IFn$_invoke$arity$5 = (function (db,index,c0,c1,c2){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db.find_datom(db,index,c0,c1,c2,null);\n}));\n\n(datascript.core.find_datom.cljs$core$IFn$_invoke$arity$6 = (function (db,index,c0,c1,c2,c3){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db.find_datom(db,index,c0,c1,c2,c3);\n}));\n\n(datascript.core.find_datom.cljs$lang$maxFixedArity = 6);\n\n/**\n * Similar to [[datoms]], but will return datoms starting from specified components and including rest of the database until the end of the index.\n * \n * If no datom matches passed arguments exactly, iterator will start from first datom that could be considered “greater” in index order.\n * \n * Usage:\n * \n *     (seek-datoms db :eavt 1)\n *     ; => (#datascript/Datom [1 :friends 2]\n *     ;     #datascript/Datom [1 :likes \"fries\"]\n *     ;     #datascript/Datom [1 :likes \"pizza\"]\n *     ;     #datascript/Datom [1 :name \"Ivan\"]\n *     ;     #datascript/Datom [2 :likes \"candy\"]\n *     ;     #datascript/Datom [2 :likes \"pie\"]\n *     ;     #datascript/Datom [2 :likes \"pizza\"])\n * \n *     (seek-datoms db :eavt 1 :name)\n *     ; => (#datascript/Datom [1 :name \"Ivan\"]\n *     ;     #datascript/Datom [2 :likes \"candy\"]\n *     ;     #datascript/Datom [2 :likes \"pie\"]\n *     ;     #datascript/Datom [2 :likes \"pizza\"])\n *   \n *     (seek-datoms db :eavt 2) \n *     ; => (#datascript/Datom [2 :likes \"candy\"]\n *     ;     #datascript/Datom [2 :likes \"pie\"]\n *     ;     #datascript/Datom [2 :likes \"pizza\"])\n *   \n *     ; no datom [2 :likes \"fish\"], so starts with one immediately following such in index\n *     (seek-datoms db :eavt 2 :likes \"fish\")\n *     ; => (#datascript/Datom [2 :likes \"pie\"]\n *     ;     #datascript/Datom [2 :likes \"pizza\"])\n */\ndatascript.core.seek_datoms = (function datascript$core$seek_datoms(var_args){\nvar G__23733 = arguments.length;\nswitch (G__23733) {\ncase 2:\nreturn datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$2 = (function (db,index){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._seek_datoms(db,index,null,null,null,null);\n}));\n\n(datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$3 = (function (db,index,c0){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._seek_datoms(db,index,c0,null,null,null);\n}));\n\n(datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$4 = (function (db,index,c0,c1){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._seek_datoms(db,index,c0,c1,null,null);\n}));\n\n(datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$5 = (function (db,index,c0,c1,c2){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._seek_datoms(db,index,c0,c1,c2,null);\n}));\n\n(datascript.core.seek_datoms.cljs$core$IFn$_invoke$arity$6 = (function (db,index,c0,c1,c2,c3){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._seek_datoms(db,index,c0,c1,c2,c3);\n}));\n\n(datascript.core.seek_datoms.cljs$lang$maxFixedArity = 6);\n\n/**\n * Same as [[seek-datoms]], but goes backwards until the beginning of the index.\n */\ndatascript.core.rseek_datoms = (function datascript$core$rseek_datoms(var_args){\nvar G__23736 = arguments.length;\nswitch (G__23736) {\ncase 2:\nreturn datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 5:\nreturn datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase 6:\nreturn datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$2 = (function (db,index){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._rseek_datoms(db,index,null,null,null,null);\n}));\n\n(datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$3 = (function (db,index,c0){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._rseek_datoms(db,index,c0,null,null,null);\n}));\n\n(datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$4 = (function (db,index,c0,c1){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._rseek_datoms(db,index,c0,c1,null,null);\n}));\n\n(datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$5 = (function (db,index,c0,c1,c2){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._rseek_datoms(db,index,c0,c1,c2,null);\n}));\n\n(datascript.core.rseek_datoms.cljs$core$IFn$_invoke$arity$6 = (function (db,index,c0,c1,c2,c3){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._rseek_datoms(db,index,c0,c1,c2,c3);\n}));\n\n(datascript.core.rseek_datoms.cljs$lang$maxFixedArity = 6);\n\n/**\n * Returns part of `:avet` index between `[_ attr start]` and `[_ attr end]` in AVET sort order.\n *   \n * Same properties as [[datoms]].\n * \n * `attr` must be a reference, unique attribute or marked as `:db/index true`.\n * \n * Usage:\n * \n *     (index-range db :likes \"a\" \"zzzzzzzzz\")\n *     ; => (#datascript/Datom [2 :likes \"candy\"]\n *     ;     #datascript/Datom [1 :likes \"fries\"]\n *     ;     #datascript/Datom [2 :likes \"pie\"]\n *     ;     #datascript/Datom [1 :likes \"pizza\"]\n *     ;     #datascript/Datom [2 :likes \"pizza\"])\n *      \n *     (index-range db :likes \"egg\" \"pineapple\")\n *     ; => (#datascript/Datom [1 :likes \"fries\"]\n *     ;     #datascript/Datom [2 :likes \"pie\"])\n *         \n * Useful patterns:\n *   \n *     ; find all entities with age in a specific range (inclusive)\n *     (->> (index-range db :age 18 60) (map :e))\n */\ndatascript.core.index_range = (function datascript$core$index_range(db,attr,start,end){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nreturn datascript.db._index_range(db,attr,start,end);\n});\n/**\n * Returns `true` if this is a connection to a DataScript db, `false` otherwise.\n */\ndatascript.core.conn_QMARK_ = (function datascript$core$conn_QMARK_(conn){\nvar and__5043__auto__ = (((!((conn == null))))?(((((conn.cljs$lang$protocol_mask$partition0$ & (32768))) || ((cljs.core.PROTOCOL_SENTINEL === conn.cljs$core$IDeref$))))?true:(((!conn.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.IDeref,conn):false)):cljs.core.native_satisfies_QMARK_(cljs.core.IDeref,conn));\nif(and__5043__auto__){\nreturn datascript.db.db_QMARK_(cljs.core.deref(conn));\n} else {\nreturn and__5043__auto__;\n}\n});\n/**\n * Creates a mutable reference to a given immutable database. See [[create-conn]].\n */\ndatascript.core.conn_from_db = (function datascript$core$conn_from_db(db){\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nvar temp__5806__auto__ = datascript.storage.storage(db);\nif((temp__5806__auto__ == null)){\nreturn cljs.core.atom.cljs$core$IFn$_invoke$arity$variadic(db,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"listeners\",\"listeners\",394544445),cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY)], null)], 0));\n} else {\nvar storage = temp__5806__auto__;\ndatascript.storage.store.cljs$core$IFn$_invoke$arity$1(db);\n\nreturn cljs.core.atom.cljs$core$IFn$_invoke$arity$variadic(db,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"listeners\",\"listeners\",394544445),cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY),new cljs.core.Keyword(null,\"tx-tail\",\"tx-tail\",1116487556),cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentVector.EMPTY),new cljs.core.Keyword(null,\"db-last-stored\",\"db-last-stored\",-2068760702),cljs.core.atom.cljs$core$IFn$_invoke$arity$1(db)], null)], 0));\n}\n});\n/**\n * Creates an empty DB and a mutable reference to it. See [[create-conn]].\n */\ndatascript.core.conn_from_datoms = (function datascript$core$conn_from_datoms(var_args){\nvar G__23742 = arguments.length;\nswitch (G__23742) {\ncase 1:\nreturn datascript.core.conn_from_datoms.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn datascript.core.conn_from_datoms.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.conn_from_datoms.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.conn_from_datoms.cljs$core$IFn$_invoke$arity$1 = (function (datoms){\nreturn datascript.core.conn_from_db(datascript.core.init_db.cljs$core$IFn$_invoke$arity$1(datoms));\n}));\n\n(datascript.core.conn_from_datoms.cljs$core$IFn$_invoke$arity$2 = (function (datoms,schema){\nreturn datascript.core.conn_from_db(datascript.core.init_db.cljs$core$IFn$_invoke$arity$2(datoms,schema));\n}));\n\n(datascript.core.conn_from_datoms.cljs$core$IFn$_invoke$arity$3 = (function (datoms,schema,opts){\nreturn datascript.core.conn_from_db(datascript.core.init_db.cljs$core$IFn$_invoke$arity$3(datoms,schema,opts));\n}));\n\n(datascript.core.conn_from_datoms.cljs$lang$maxFixedArity = 3);\n\n/**\n * Creates a mutable reference (a “connection”) to an empty immutable database.\n * \n * Connections are lightweight in-memory structures (~atoms) with direct support of transaction listeners ([[listen!]], [[unlisten!]]) and other handy DataScript APIs ([[transact!]], [[reset-conn!]], [[db]]).\n * \n * To access underlying immutable DB value, deref: `@conn`.\n * \n * For list of options, see [[empty-db]].\n * \n * If you specify `:storage` option, conn will be stored automatically after each transaction\n */\ndatascript.core.create_conn = (function datascript$core$create_conn(var_args){\nvar G__23750 = arguments.length;\nswitch (G__23750) {\ncase 0:\nreturn datascript.core.create_conn.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn datascript.core.create_conn.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn datascript.core.create_conn.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.create_conn.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn datascript.core.conn_from_db(datascript.core.empty_db.cljs$core$IFn$_invoke$arity$0());\n}));\n\n(datascript.core.create_conn.cljs$core$IFn$_invoke$arity$1 = (function (schema){\nreturn datascript.core.conn_from_db(datascript.core.empty_db.cljs$core$IFn$_invoke$arity$1(schema));\n}));\n\n(datascript.core.create_conn.cljs$core$IFn$_invoke$arity$2 = (function (schema,opts){\nreturn datascript.core.conn_from_db(datascript.core.empty_db.cljs$core$IFn$_invoke$arity$2(schema,opts));\n}));\n\n(datascript.core.create_conn.cljs$lang$maxFixedArity = 2);\n\ndatascript.core._transact_BANG_ = (function datascript$core$_transact_BANG_(conn,tx_data,tx_meta){\nif(datascript.core.conn_QMARK_(conn)){\n} else {\nthrow (new Error(\"Assert failed: (conn? conn)\"));\n}\n\nvar _STAR_report = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(null);\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(conn,(function (db){\nvar r = datascript.core.with$.cljs$core$IFn$_invoke$arity$3(db,tx_data,tx_meta);\ncljs.core.reset_BANG_(_STAR_report,r);\n\nreturn new cljs.core.Keyword(null,\"db-after\",\"db-after\",-571884666).cljs$core$IFn$_invoke$arity$1(r);\n}));\n\nreturn cljs.core.deref(_STAR_report);\n});\n/**\n * Applies transaction the underlying database value and atomically updates connection reference to point to the result of that transaction, new db value.\n *   \n * Returns transaction report, a map:\n * \n *     { :db-before ...       ; db value before transaction\n *       :db-after  ...       ; db value after transaction\n *       :tx-data   [...]     ; plain datoms that were added/retracted from db-before\n *       :tempids   {...}     ; map of tempid from tx-data => assigned entid in db-after\n *       :tx-meta   tx-meta } ; the exact value you passed as `tx-meta`\n * \n *   Note! `conn` will be updated in-place and is not returned from [[transact!]].\n *   \n *   Usage:\n * \n *    ; add a single datom to an existing entity (1)\n *    (transact! conn [[:db/add 1 :name \"Ivan\"]])\n *   \n *    ; retract a single datom\n *    (transact! conn [[:db/retract 1 :name \"Ivan\"]])\n *   \n *    ; retract single entity attribute\n *    (transact! conn [[:db.fn/retractAttribute 1 :name]])\n *   \n *    ; ... or equivalently (since Datomic changed its API to support this):\n *    (transact! conn [[:db/retract 1 :name]])\n *    \n *    ; retract all entity attributes (effectively deletes entity)\n *    (transact! conn [[:db.fn/retractEntity 1]])\n *   \n *    ; create a new entity (`-1`, as any other negative value, is a tempid\n *    ; that will be replaced with DataScript to a next unused eid)\n *    (transact! conn [[:db/add -1 :name \"Ivan\"]])\n *   \n *    ; check assigned id (here `*1` is a result returned from previous `transact!` call)\n *    (def report *1)\n *    (:tempids report) ; => {-1 296}\n *   \n *    ; check actual datoms inserted\n *    (:tx-data report) ; => [#datascript/Datom [296 :name \"Ivan\"]]\n *   \n *    ; tempid can also be a string\n *    (transact! conn [[:db/add \"ivan\" :name \"Ivan\"]])\n *    (:tempids *1) ; => {\"ivan\" 297}\n *   \n *    ; reference another entity (must exist)\n *    (transact! conn [[:db/add -1 :friend 296]])\n *   \n *    ; create an entity and set multiple attributes (in a single transaction\n *    ; equal tempids will be replaced with the same yet unused entid)\n *    (transact! conn [[:db/add -1 :name \"Ivan\"]\n *                     [:db/add -1 :likes \"fries\"]\n *                     [:db/add -1 :likes \"pizza\"]\n *                     [:db/add -1 :friend 296]])\n *   \n *    ; create an entity and set multiple attributes (alternative map form)\n *    (transact! conn [{:db/id  -1\n *                      :name   \"Ivan\"\n *                      :likes  [\"fries\" \"pizza\"]\n *                      :friend 296}])\n *    \n *    ; update an entity (alternative map form). Can’t retract attributes in\n *    ; map form. For cardinality many attrs, value (fish in this example)\n *    ; will be added to the list of existing values\n *    (transact! conn [{:db/id  296\n *                      :name   \"Oleg\"\n *                      :likes  [\"fish\"]}])\n * \n *    ; ref attributes can be specified as nested map, that will create nested entity as well\n *    (transact! conn [{:db/id  -1\n *                      :name   \"Oleg\"\n *                      :friend {:db/id -2\n *                               :name \"Sergey\"}}])\n *                               \n *    ; reverse attribute name can be used if you want created entity to become\n *    ; a value in another entity reference\n *    (transact! conn [{:db/id  -1\n *                      :name   \"Oleg\"\n *                      :_friend 296}])\n *    ; equivalent to\n *    (transact! conn [{:db/id  -1, :name   \"Oleg\"}\n *                     {:db/id 296, :friend -1}])\n *    ; equivalent to\n *    (transact! conn [[:db/add  -1 :name   \"Oleg\"]\n *                     [:db/add 296 :friend -1]])\n */\ndatascript.core.transact_BANG_ = (function datascript$core$transact_BANG_(var_args){\nvar G__23770 = arguments.length;\nswitch (G__23770) {\ncase 2:\nreturn datascript.core.transact_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.transact_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.transact_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (conn,tx_data){\nreturn datascript.core.transact_BANG_.cljs$core$IFn$_invoke$arity$3(conn,tx_data,null);\n}));\n\n(datascript.core.transact_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (conn,tx_data,tx_meta){\nif(datascript.core.conn_QMARK_(conn)){\n} else {\nthrow (new Error(\"Assert failed: (conn? conn)\"));\n}\n\nvar report = datascript.core._transact_BANG_(conn,tx_data,tx_meta);\nvar seq__23771_23909 = cljs.core.seq((function (){var G__23782 = new cljs.core.Keyword(null,\"listeners\",\"listeners\",394544445).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(conn));\nif((G__23782 == null)){\nreturn null;\n} else {\nreturn cljs.core.deref(G__23782);\n}\n})());\nvar chunk__23772_23910 = null;\nvar count__23773_23911 = (0);\nvar i__23774_23912 = (0);\nwhile(true){\nif((i__23774_23912 < count__23773_23911)){\nvar vec__23784_23913 = chunk__23772_23910.cljs$core$IIndexed$_nth$arity$2(null,i__23774_23912);\nvar __23914 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23784_23913,(0),null);\nvar callback_23915 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23784_23913,(1),null);\n(callback_23915.cljs$core$IFn$_invoke$arity$1 ? callback_23915.cljs$core$IFn$_invoke$arity$1(report) : callback_23915.call(null,report));\n\n\nvar G__23916 = seq__23771_23909;\nvar G__23917 = chunk__23772_23910;\nvar G__23918 = count__23773_23911;\nvar G__23919 = (i__23774_23912 + (1));\nseq__23771_23909 = G__23916;\nchunk__23772_23910 = G__23917;\ncount__23773_23911 = G__23918;\ni__23774_23912 = G__23919;\ncontinue;\n} else {\nvar temp__5804__auto___23920 = cljs.core.seq(seq__23771_23909);\nif(temp__5804__auto___23920){\nvar seq__23771_23921__$1 = temp__5804__auto___23920;\nif(cljs.core.chunked_seq_QMARK_(seq__23771_23921__$1)){\nvar c__5568__auto___23922 = cljs.core.chunk_first(seq__23771_23921__$1);\nvar G__23923 = cljs.core.chunk_rest(seq__23771_23921__$1);\nvar G__23924 = c__5568__auto___23922;\nvar G__23925 = cljs.core.count(c__5568__auto___23922);\nvar G__23926 = (0);\nseq__23771_23909 = G__23923;\nchunk__23772_23910 = G__23924;\ncount__23773_23911 = G__23925;\ni__23774_23912 = G__23926;\ncontinue;\n} else {\nvar vec__23789_23927 = cljs.core.first(seq__23771_23921__$1);\nvar __23928 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23789_23927,(0),null);\nvar callback_23929 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23789_23927,(1),null);\n(callback_23929.cljs$core$IFn$_invoke$arity$1 ? callback_23929.cljs$core$IFn$_invoke$arity$1(report) : callback_23929.call(null,report));\n\n\nvar G__23930 = cljs.core.next(seq__23771_23921__$1);\nvar G__23931 = null;\nvar G__23932 = (0);\nvar G__23933 = (0);\nseq__23771_23909 = G__23930;\nchunk__23772_23910 = G__23931;\ncount__23773_23911 = G__23932;\ni__23774_23912 = G__23933;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn report;\n}));\n\n(datascript.core.transact_BANG_.cljs$lang$maxFixedArity = 3);\n\n/**\n * Forces underlying `conn` value to become `db`. Will generate a tx-report that will remove everything from old value and insert everything from the new one.\n */\ndatascript.core.reset_conn_BANG_ = (function datascript$core$reset_conn_BANG_(var_args){\nvar G__23794 = arguments.length;\nswitch (G__23794) {\ncase 2:\nreturn datascript.core.reset_conn_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.reset_conn_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.reset_conn_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (conn,db){\nreturn datascript.core.reset_conn_BANG_.cljs$core$IFn$_invoke$arity$3(conn,db,null);\n}));\n\n(datascript.core.reset_conn_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (conn,db,tx_meta){\nif(datascript.core.conn_QMARK_(conn)){\n} else {\nthrow (new Error(\"Assert failed: (conn? conn)\"));\n}\n\nif(datascript.db.db_QMARK_(db)){\n} else {\nthrow (new Error(\"Assert failed: (db/db? db)\"));\n}\n\nvar db_before = cljs.core.deref(conn);\nvar report = datascript.db.map__GT_TxReport(new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"db-before\",\"db-before\",-553691536),db_before,new cljs.core.Keyword(null,\"db-after\",\"db-after\",-571884666),db,new cljs.core.Keyword(null,\"tx-data\",\"tx-data\",934159761),cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__23792_SHARP_){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(p1__23792_SHARP_,new cljs.core.Keyword(null,\"added\",\"added\",2057651688),false);\n}),datascript.core.datoms.cljs$core$IFn$_invoke$arity$2(db_before,new cljs.core.Keyword(null,\"eavt\",\"eavt\",-666437073))),datascript.core.datoms.cljs$core$IFn$_invoke$arity$2(db,new cljs.core.Keyword(null,\"eavt\",\"eavt\",-666437073))),new cljs.core.Keyword(null,\"tx-meta\",\"tx-meta\",1159283194),tx_meta], null));\ncljs.core.reset_BANG_(conn,db);\n\nvar seq__23795_23935 = cljs.core.seq((function (){var G__23807 = new cljs.core.Keyword(null,\"listeners\",\"listeners\",394544445).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(conn));\nif((G__23807 == null)){\nreturn null;\n} else {\nreturn cljs.core.deref(G__23807);\n}\n})());\nvar chunk__23796_23936 = null;\nvar count__23797_23937 = (0);\nvar i__23798_23938 = (0);\nwhile(true){\nif((i__23798_23938 < count__23797_23937)){\nvar vec__23808_23939 = chunk__23796_23936.cljs$core$IIndexed$_nth$arity$2(null,i__23798_23938);\nvar __23940 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23808_23939,(0),null);\nvar callback_23941 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23808_23939,(1),null);\n(callback_23941.cljs$core$IFn$_invoke$arity$1 ? callback_23941.cljs$core$IFn$_invoke$arity$1(report) : callback_23941.call(null,report));\n\n\nvar G__23942 = seq__23795_23935;\nvar G__23943 = chunk__23796_23936;\nvar G__23944 = count__23797_23937;\nvar G__23945 = (i__23798_23938 + (1));\nseq__23795_23935 = G__23942;\nchunk__23796_23936 = G__23943;\ncount__23797_23937 = G__23944;\ni__23798_23938 = G__23945;\ncontinue;\n} else {\nvar temp__5804__auto___23946 = cljs.core.seq(seq__23795_23935);\nif(temp__5804__auto___23946){\nvar seq__23795_23947__$1 = temp__5804__auto___23946;\nif(cljs.core.chunked_seq_QMARK_(seq__23795_23947__$1)){\nvar c__5568__auto___23948 = cljs.core.chunk_first(seq__23795_23947__$1);\nvar G__23949 = cljs.core.chunk_rest(seq__23795_23947__$1);\nvar G__23950 = c__5568__auto___23948;\nvar G__23951 = cljs.core.count(c__5568__auto___23948);\nvar G__23952 = (0);\nseq__23795_23935 = G__23949;\nchunk__23796_23936 = G__23950;\ncount__23797_23937 = G__23951;\ni__23798_23938 = G__23952;\ncontinue;\n} else {\nvar vec__23811_23953 = cljs.core.first(seq__23795_23947__$1);\nvar __23954 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23811_23953,(0),null);\nvar callback_23955 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23811_23953,(1),null);\n(callback_23955.cljs$core$IFn$_invoke$arity$1 ? callback_23955.cljs$core$IFn$_invoke$arity$1(report) : callback_23955.call(null,report));\n\n\nvar G__23956 = cljs.core.next(seq__23795_23947__$1);\nvar G__23957 = null;\nvar G__23958 = (0);\nvar G__23959 = (0);\nseq__23795_23935 = G__23956;\nchunk__23796_23936 = G__23957;\ncount__23797_23937 = G__23958;\ni__23798_23938 = G__23959;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\nreturn db;\n}));\n\n(datascript.core.reset_conn_BANG_.cljs$lang$maxFixedArity = 3);\n\ndatascript.core.reset_schema_BANG_ = (function datascript$core$reset_schema_BANG_(conn,schema){\n\nnew cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"pre\",\"pre\",2118456869),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [datascript.core.conn_QMARK_(conn)], null)], null);\n\nvar db = cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(conn,datascript.db.with_schema,schema);\nreturn db;\n});\ndatascript.core.atom_QMARK_ = (function datascript$core$atom_QMARK_(a){\nreturn (a instanceof cljs.core.Atom);\n});\n/**\n * Listen for changes on the given connection. Whenever a transaction is applied to the database via [[transact!]], the callback is called\n * with the transaction report. `key` is any opaque unique value.\n * \n * Idempotent. Calling [[listen!]] with the same key twice will override old callback with the new value.\n * \n * Returns the key under which this listener is registered. See also [[unlisten!]].\n */\ndatascript.core.listen_BANG_ = (function datascript$core$listen_BANG_(var_args){\nvar G__23816 = arguments.length;\nswitch (G__23816) {\ncase 2:\nreturn datascript.core.listen_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.listen_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.listen_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (conn,callback){\nreturn datascript.core.listen_BANG_.cljs$core$IFn$_invoke$arity$3(conn,cljs.core.rand.cljs$core$IFn$_invoke$arity$0(),callback);\n}));\n\n(datascript.core.listen_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (conn,key,callback){\nif(datascript.core.conn_QMARK_(conn)){\n} else {\nthrow (new Error(\"Assert failed: (conn? conn)\"));\n}\n\nif(datascript.core.atom_QMARK_(new cljs.core.Keyword(null,\"listeners\",\"listeners\",394544445).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(conn)))){\n} else {\nthrow (new Error(\"Assert failed: (atom? (:listeners (meta conn)))\"));\n}\n\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$4(new cljs.core.Keyword(null,\"listeners\",\"listeners\",394544445).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(conn)),cljs.core.assoc,key,callback);\n\nreturn key;\n}));\n\n(datascript.core.listen_BANG_.cljs$lang$maxFixedArity = 3);\n\n/**\n * Removes registered listener from connection. See also [[listen!]].\n */\ndatascript.core.unlisten_BANG_ = (function datascript$core$unlisten_BANG_(conn,key){\nif(datascript.core.conn_QMARK_(conn)){\n} else {\nthrow (new Error(\"Assert failed: (conn? conn)\"));\n}\n\nif(datascript.core.atom_QMARK_(new cljs.core.Keyword(null,\"listeners\",\"listeners\",394544445).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(conn)))){\n} else {\nthrow (new Error(\"Assert failed: (atom? (:listeners (meta conn)))\"));\n}\n\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$3(new cljs.core.Keyword(null,\"listeners\",\"listeners\",394544445).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(conn)),cljs.core.dissoc,key);\n});\n/**\n * Data readers for EDN readers. In CLJS they’re registered automatically. In CLJ, if `data_readers.clj` do not work, you can always do\n * \n *           ```\n *           (clojure.edn/read-string {:readers data-readers} \"...\")\n *           ```\n */\ndatascript.core.data_readers = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Symbol(\"datascript\",\"Datom\",\"datascript/Datom\",-901340080,null),datascript.db.datom_from_reader,new cljs.core.Symbol(\"datascript\",\"DB\",\"datascript/DB\",-487332776,null),datascript.db.db_from_reader], null);\nvar seq__23823_23961 = cljs.core.seq(datascript.core.data_readers);\nvar chunk__23824_23962 = null;\nvar count__23825_23963 = (0);\nvar i__23826_23964 = (0);\nwhile(true){\nif((i__23826_23964 < count__23825_23963)){\nvar vec__23835_23965 = chunk__23824_23962.cljs$core$IIndexed$_nth$arity$2(null,i__23826_23964);\nvar tag_23966 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23835_23965,(0),null);\nvar cb_23967 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23835_23965,(1),null);\ncljs.reader.register_tag_parser_BANG_(tag_23966,cb_23967);\n\n\nvar G__23969 = seq__23823_23961;\nvar G__23970 = chunk__23824_23962;\nvar G__23971 = count__23825_23963;\nvar G__23972 = (i__23826_23964 + (1));\nseq__23823_23961 = G__23969;\nchunk__23824_23962 = G__23970;\ncount__23825_23963 = G__23971;\ni__23826_23964 = G__23972;\ncontinue;\n} else {\nvar temp__5804__auto___23973 = cljs.core.seq(seq__23823_23961);\nif(temp__5804__auto___23973){\nvar seq__23823_23974__$1 = temp__5804__auto___23973;\nif(cljs.core.chunked_seq_QMARK_(seq__23823_23974__$1)){\nvar c__5568__auto___23975 = cljs.core.chunk_first(seq__23823_23974__$1);\nvar G__23976 = cljs.core.chunk_rest(seq__23823_23974__$1);\nvar G__23977 = c__5568__auto___23975;\nvar G__23978 = cljs.core.count(c__5568__auto___23975);\nvar G__23979 = (0);\nseq__23823_23961 = G__23976;\nchunk__23824_23962 = G__23977;\ncount__23825_23963 = G__23978;\ni__23826_23964 = G__23979;\ncontinue;\n} else {\nvar vec__23839_23980 = cljs.core.first(seq__23823_23974__$1);\nvar tag_23981 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23839_23980,(0),null);\nvar cb_23982 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__23839_23980,(1),null);\ncljs.reader.register_tag_parser_BANG_(tag_23981,cb_23982);\n\n\nvar G__23983 = cljs.core.next(seq__23823_23974__$1);\nvar G__23984 = null;\nvar G__23985 = (0);\nvar G__23986 = (0);\nseq__23823_23961 = G__23983;\nchunk__23824_23962 = G__23984;\ncount__23825_23963 = G__23985;\ni__23826_23964 = G__23986;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\ndatascript.core.last_tempid = cljs.core.atom.cljs$core$IFn$_invoke$arity$1((-1000000));\n/**\n * Allocates and returns an unique temporary id (a negative integer). Ignores `part`. Returns `x` if it is specified.\n *   \n * Exists for Datomic API compatibility. Prefer using negative integers directly if possible.\n */\ndatascript.core.tempid = (function datascript$core$tempid(var_args){\nvar G__23843 = arguments.length;\nswitch (G__23843) {\ncase 1:\nreturn datascript.core.tempid.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn datascript.core.tempid.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.tempid.cljs$core$IFn$_invoke$arity$1 = (function (part){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(part,new cljs.core.Keyword(\"db.part\",\"tx\",\"db.part/tx\",-1480923213))){\nreturn new cljs.core.Keyword(\"db\",\"current-tx\",\"db/current-tx\",1600722132);\n} else {\nreturn cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(datascript.core.last_tempid,cljs.core.dec);\n}\n}));\n\n(datascript.core.tempid.cljs$core$IFn$_invoke$arity$2 = (function (part,x){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(part,new cljs.core.Keyword(\"db.part\",\"tx\",\"db.part/tx\",-1480923213))){\nreturn new cljs.core.Keyword(\"db\",\"current-tx\",\"db/current-tx\",1600722132);\n} else {\nreturn x;\n}\n}));\n\n(datascript.core.tempid.cljs$lang$maxFixedArity = 2);\n\n/**\n * Does a lookup in tempids map, returning an entity id that tempid was resolved to.\n * \n * Exists for Datomic API compatibility. Prefer using map lookup directly if possible.\n */\ndatascript.core.resolve_tempid = (function datascript$core$resolve_tempid(_db,tempids,tempid){\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(tempids,tempid);\n});\n/**\n * Returns the underlying immutable database value from a connection.\n * \n * Exists for Datomic API compatibility. Prefer using `@conn` directly if possible.\n */\ndatascript.core.db = (function datascript$core$db(conn){\nif(datascript.core.conn_QMARK_(conn)){\n} else {\nthrow (new Error(\"Assert failed: (conn? conn)\"));\n}\n\nreturn cljs.core.deref(conn);\n});\n\n/**\n* @constructor\n * @implements {cljs.core.IDerefWithTimeout}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IDeref}\n * @implements {cljs.core.IWithMeta}\n*/\ndatascript.core.t_datascript$core23848 = (function (conn,tx_data,tx_meta,res,meta23849){\nthis.conn = conn;\nthis.tx_data = tx_data;\nthis.tx_meta = tx_meta;\nthis.res = res;\nthis.meta23849 = meta23849;\nthis.cljs$lang$protocol_mask$partition0$ = 491520;\nthis.cljs$lang$protocol_mask$partition1$ = 1;\n});\n(datascript.core.t_datascript$core23848.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (_23850,meta23849__$1){\nvar self__ = this;\nvar _23850__$1 = this;\nreturn (new datascript.core.t_datascript$core23848(self__.conn,self__.tx_data,self__.tx_meta,self__.res,meta23849__$1));\n}));\n\n(datascript.core.t_datascript$core23848.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_23850){\nvar self__ = this;\nvar _23850__$1 = this;\nreturn self__.meta23849;\n}));\n\n(datascript.core.t_datascript$core23848.prototype.cljs$core$IDeref$_deref$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn self__.res;\n}));\n\n(datascript.core.t_datascript$core23848.prototype.cljs$core$IDerefWithTimeout$_deref_with_timeout$arity$3 = (function (_,___$1,___$2){\nvar self__ = this;\nvar ___$3 = this;\nreturn self__.res;\n}));\n\n(datascript.core.t_datascript$core23848.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn true;\n}));\n\n(datascript.core.t_datascript$core23848.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"conn\",\"conn\",1918841190,null),new cljs.core.Symbol(null,\"tx-data\",\"tx-data\",-1720276008,null),new cljs.core.Symbol(null,\"tx-meta\",\"tx-meta\",-1495152575,null),new cljs.core.Symbol(null,\"res\",\"res\",245523648,null),new cljs.core.Symbol(null,\"meta23849\",\"meta23849\",336256035,null)], null);\n}));\n\n(datascript.core.t_datascript$core23848.cljs$lang$type = true);\n\n(datascript.core.t_datascript$core23848.cljs$lang$ctorStr = \"datascript.core/t_datascript$core23848\");\n\n(datascript.core.t_datascript$core23848.cljs$lang$ctorPrWriter = (function (this__5330__auto__,writer__5331__auto__,opt__5332__auto__){\nreturn cljs.core._write(writer__5331__auto__,\"datascript.core/t_datascript$core23848\");\n}));\n\n/**\n * Positional factory function for datascript.core/t_datascript$core23848.\n */\ndatascript.core.__GT_t_datascript$core23848 = (function datascript$core$__GT_t_datascript$core23848(conn,tx_data,tx_meta,res,meta23849){\nreturn (new datascript.core.t_datascript$core23848(conn,tx_data,tx_meta,res,meta23849));\n});\n\n\n/**\n * Same as [[transact!]], but returns an immediately realized future.\n *   \n * Exists for Datomic API compatibility. Prefer using [[transact!]] if possible.\n */\ndatascript.core.transact = (function datascript$core$transact(var_args){\nvar G__23845 = arguments.length;\nswitch (G__23845) {\ncase 2:\nreturn datascript.core.transact.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.transact.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.transact.cljs$core$IFn$_invoke$arity$2 = (function (conn,tx_data){\nreturn datascript.core.transact.cljs$core$IFn$_invoke$arity$3(conn,tx_data,null);\n}));\n\n(datascript.core.transact.cljs$core$IFn$_invoke$arity$3 = (function (conn,tx_data,tx_meta){\nif(datascript.core.conn_QMARK_(conn)){\n} else {\nthrow (new Error(\"Assert failed: (conn? conn)\"));\n}\n\nvar res = datascript.core.transact_BANG_.cljs$core$IFn$_invoke$arity$3(conn,tx_data,tx_meta);\nreturn (new datascript.core.t_datascript$core23848(conn,tx_data,tx_meta,res,cljs.core.PersistentArrayMap.EMPTY));\n}));\n\n(datascript.core.transact.cljs$lang$maxFixedArity = 3);\n\n\n/**\n* @constructor\n * @implements {cljs.core.IDerefWithTimeout}\n * @implements {cljs.core.IPending}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.IDeref}\n * @implements {cljs.core.IWithMeta}\n*/\ndatascript.core.t_datascript$core23866 = (function (f,res,realized,meta23867){\nthis.f = f;\nthis.res = res;\nthis.realized = realized;\nthis.meta23867 = meta23867;\nthis.cljs$lang$protocol_mask$partition0$ = 491520;\nthis.cljs$lang$protocol_mask$partition1$ = 1;\n});\n(datascript.core.t_datascript$core23866.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (_23868,meta23867__$1){\nvar self__ = this;\nvar _23868__$1 = this;\nreturn (new datascript.core.t_datascript$core23866(self__.f,self__.res,self__.realized,meta23867__$1));\n}));\n\n(datascript.core.t_datascript$core23866.prototype.cljs$core$IMeta$_meta$arity$1 = (function (_23868){\nvar self__ = this;\nvar _23868__$1 = this;\nreturn self__.meta23867;\n}));\n\n(datascript.core.t_datascript$core23866.prototype.cljs$core$IDeref$_deref$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.deref(self__.res);\n}));\n\n(datascript.core.t_datascript$core23866.prototype.cljs$core$IDerefWithTimeout$_deref_with_timeout$arity$3 = (function (_,___$1,timeout_val){\nvar self__ = this;\nvar ___$2 = this;\nif(cljs.core.truth_(cljs.core.deref(self__.realized))){\nreturn cljs.core.deref(self__.res);\n} else {\nreturn timeout_val;\n}\n}));\n\n(datascript.core.t_datascript$core23866.prototype.cljs$core$IPending$_realized_QMARK_$arity$1 = (function (_){\nvar self__ = this;\nvar ___$1 = this;\nreturn cljs.core.deref(self__.realized);\n}));\n\n(datascript.core.t_datascript$core23866.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"f\",\"f\",43394975,null),new cljs.core.Symbol(null,\"res\",\"res\",245523648,null),new cljs.core.Symbol(null,\"realized\",\"realized\",1487343404,null),new cljs.core.Symbol(null,\"meta23867\",\"meta23867\",594792206,null)], null);\n}));\n\n(datascript.core.t_datascript$core23866.cljs$lang$type = true);\n\n(datascript.core.t_datascript$core23866.cljs$lang$ctorStr = \"datascript.core/t_datascript$core23866\");\n\n(datascript.core.t_datascript$core23866.cljs$lang$ctorPrWriter = (function (this__5330__auto__,writer__5331__auto__,opt__5332__auto__){\nreturn cljs.core._write(writer__5331__auto__,\"datascript.core/t_datascript$core23866\");\n}));\n\n/**\n * Positional factory function for datascript.core/t_datascript$core23866.\n */\ndatascript.core.__GT_t_datascript$core23866 = (function datascript$core$__GT_t_datascript$core23866(f,res,realized,meta23867){\nreturn (new datascript.core.t_datascript$core23866(f,res,realized,meta23867));\n});\n\n\ndatascript.core.future_call = (function datascript$core$future_call(f){\nvar res = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(null);\nvar realized = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(false);\nsetTimeout((function (){\ncljs.core.reset_BANG_(res,(f.cljs$core$IFn$_invoke$arity$0 ? f.cljs$core$IFn$_invoke$arity$0() : f.call(null)));\n\nreturn cljs.core.reset_BANG_(realized,true);\n}),(0));\n\nreturn (new datascript.core.t_datascript$core23866(f,res,realized,cljs.core.PersistentArrayMap.EMPTY));\n});\n/**\n * In CLJ, calls [[transact!]] on a future thread pool, returning immediately.\n *   \n * In CLJS, just calls [[transact!]] and returns a realized future.\n */\ndatascript.core.transact_async = (function datascript$core$transact_async(var_args){\nvar G__23873 = arguments.length;\nswitch (G__23873) {\ncase 2:\nreturn datascript.core.transact_async.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn datascript.core.transact_async.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(datascript.core.transact_async.cljs$core$IFn$_invoke$arity$2 = (function (conn,tx_data){\nreturn datascript.core.transact_async.cljs$core$IFn$_invoke$arity$3(conn,tx_data,null);\n}));\n\n(datascript.core.transact_async.cljs$core$IFn$_invoke$arity$3 = (function (conn,tx_data,tx_meta){\nif(datascript.core.conn_QMARK_(conn)){\n} else {\nthrow (new Error(\"Assert failed: (conn? conn)\"));\n}\n\nreturn datascript.core.future_call((function (){\nreturn datascript.core.transact_BANG_.cljs$core$IFn$_invoke$arity$3(conn,tx_data,tx_meta);\n}));\n}));\n\n(datascript.core.transact_async.cljs$lang$maxFixedArity = 3);\n\n/**\n * Generates a UUID that grow with time. Such UUIDs will always go to the end  of the index and that will minimize insertions in the middle.\n *   \n * Consist of 64 bits of current UNIX timestamp (in seconds) and 64 random bits (2^64 different unique values per second).\n */\ndatascript.core.squuid = datascript.util.squuid;\n/**\n * Returns time that was used in [[squuid]] call, in milliseconds, rounded to the closest second.\n */\ndatascript.core.squuid_time_millis = datascript.util.squuid_time_millis;\ndatascript.core.settings = (function datascript$core$settings(db){\nreturn me.tonsky.persistent_sorted_set.settings(new cljs.core.Keyword(null,\"eavt\",\"eavt\",-666437073).cljs$core$IFn$_invoke$arity$1(db));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","datascript/core.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",20],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",null,"~:excludes",["~#set",["~$filter"]],"~:name","~$datascript.core","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$set","~$me.tonsky.persistent-sorted-set","~$datascript.query","^S","~$datascript.util","^T","~$cljs.core","^U","~$goog","^V","~$db","~$datascript.db","~$util","^T","~$datascript.storage","^Z","~$dq","^S","~$ds","~$datascript.serialize","^11","^11","^R","^R","^X","^X","~$datascript.pull-api","^12","~$de","~$datascript.impl.entity","~$dp","^12","~$cljs.reader","^16","~$edn","^16","~$storage","^Z","^14","^14"],"~:seen",["^H",["~:require"]],"~:uses",["^ ","~$Datom","^X","~$DB","^X","~$FilteredDB","^X"],"~:require-macros",["^ ","^U","^U","^W","^X","^10","^11","^11","^11","^X","^X","^16","^16","^17","^16"],"~:form",["~#list",["~$ns","^K",["^1A",["~:refer-clojure","~:exclude",["^I"]]],["^1A",["^1:",["^16","~:as","^17"],["^X","^1E","^W","~:refer",["^1<","^1=","^1>"]],["^12","^1E","^15"],["^11","^1E","^10"],["^Z","^1E","^18"],["^S","^1E","^["],["^14","^1E","^13"],["^T","^1E","^Y"],["^R","^1E","^Q"]]]]],"~:flags",["^ ","^1:",["^H",[]]],"~:js-deps",["^ "],"~:deps",["^V","^U","^16","^X","^12","^11","^Z","^S","^14","^T","^R"]],"^N","^K","~:resource-id",["~:shadow.build.classpath/resource","datascript/core.cljc"],"~:compiled-at",1696770187724,"^L",["^ ","^Q","^R","^S","^S","^T","^T","^U","^U","^V","^V","^W","^X","^Y","^T","^Z","^Z","^[","^S","^10","^11","^11","^11","^R","^R","^X","^X","^12","^12","^13","^14","^15","^12","^16","^16","^17","^16","^18","^Z","^14","^14"],"~:resource-name","datascript/core.cljc","~:warnings",[],"~:source","(ns datascript.core\n  (:refer-clojure :exclude [filter])\n  (:require\n    [#?(:cljs cljs.reader :clj clojure.edn) :as edn]\n    [datascript.db :as db #?@(:cljs [:refer [Datom DB FilteredDB]])]\n    #?(:clj [datascript.pprint])\n    [datascript.pull-api :as dp]\n    [datascript.serialize :as ds]\n    [datascript.storage :as storage]\n    [datascript.query :as dq]\n    [datascript.impl.entity :as de]\n    [datascript.util :as util]\n    [me.tonsky.persistent-sorted-set :as set])\n  #?(:clj\n     (:import\n       [datascript.db Datom DB FilteredDB]\n       [datascript.impl.entity Entity]\n       [java.util UUID])))\n\n(def ^:const ^:no-doc tx0 db/tx0)\n\n\n; Entities\n\n(def ^{:tag Entity\n       :arglists '([db eid])\n       :doc \"Retrieves an entity by its id from database. Entities are lazy map-like structures to navigate DataScript database content.\n\n             For `eid` pass entity id or lookup attr:\n             \n                 (entity db 1)\n                 (entity db [:unique-attr :value])\n            \n             If entity does not exist, `nil` is returned:\n\n                 (entity db 100500) ; => nil\n\n             Creating an entity by id is very cheap, almost no-op, as attr access is on-demand:\n\n                 (entity db 1) ; => {:db/id 1}\n\n             Entity attributes can be lazily accessed through key lookups:\n             \n                 (:attr (entity db 1)) ; => :value\n                 (get (entity db 1) :attr) ; => :value\n\n             Cardinality many attributes are returned sequences:\n\n                 (:attrs (entity db 1)) ; => [:v1 :v2 :v3]\n\n             Reference attributes are returned as another entities:\n\n                 (:ref (entity db 1)) ; => {:db/id 2}\n                 (:ns/ref (entity db 1)) ; => {:db/id 2}\n\n             References can be walked backwards by prepending `_` to name part of an attribute:\n\n                 (:_ref (entity db 2)) ; => [{:db/id 1}]\n                 (:ns/_ref (entity db 2)) ; => [{:db/id 1}]\n             \n             Reverse reference lookup returns sequence of entities unless attribute is marked as `:db/isComponent`:\n\n                 (:_component-ref (entity db 2)) ; => {:db/id 1}\n\n             Entity gotchas:\n               \n             - Entities print as map, but are not exactly maps (they have compatible get interface though).\n             - Entities are effectively immutable “views” into a particular version of a database.\n             - Entities retain reference to the whole database.\n             - You can’t change database through entities, only read.\n             - Creating an entity by id is very cheap, almost no-op (attributes are looked up on demand).\n             - Comparing entities just compares their ids. Be careful when comparing entities taken from different dbs or from different versions of the same db.\n             - Accessed entity attributes are cached on entity itself (except backward references).\n             - When printing, only cached attributes (the ones you have accessed before) are printed. See [[touch]].\"}\n  entity de/entity)\n\n(def ^{:arglists '([db eid])\n       :doc \"Given lookup ref `[unique-attr value]`, returns numberic entity id.\n\n             If entity does not exist, returns `nil`.\"}\n  entid db/entid)\n\n(defn ^DB entity-db\n  \"Returns a db that entity was created from.\"\n  [^Entity entity]\n  {:pre [(de/entity? entity)]}\n  (.-db entity))\n\n(def ^{:tag Entity\n       :arglists '([e])\n       :doc \"Forces all entity attributes to be eagerly fetched and cached. Only usable for debug output.\n\n             Usage:\n\n             ```\n             (entity db 1) ; => {:db/id 1}\n             (touch (entity db 1)) ; => {:db/id 1, :dislikes [:pie], :likes [:pizza]}\n             ```\"}\n  touch de/touch)\n\n\n; Pull\n\n(def ^{:arglists '([db selector eid])\n       :doc \"Fetches data from database using recursive declarative description. See [docs.datomic.com/on-prem/pull.html](https://docs.datomic.com/on-prem/pull.html).\n\n             Unlike [[entity]], returns plain Clojure map (not lazy).\n\n             Usage:\n\n                 (pull db [:db/id, :name, :likes, {:friends [:db/id :name]}] 1)\n                 ; => {:db/id   1,\n                 ;     :name    \\\"Ivan\\\"\n                 ;     :likes   [:pizza]\n                 ;     :friends [{:db/id 2, :name \\\"Oleg\\\"}]}\"}\n  pull dp/pull)\n\n(def ^{:arglists '([db selector eids])\n       :doc \"Same as [[pull]], but accepts sequence of ids and returns sequence of maps.\n\n             Usage:\n\n             ```\n             (pull-many db [:db/id :name] [1 2])\n             ; => [{:db/id 1, :name \\\"Ivan\\\"}\n             ;     {:db/id 2, :name \\\"Oleg\\\"}]\n             ```\"}\n  pull-many dp/pull-many)\n\n; Query\n\n(def\n  ^{:arglists '([query & inputs])\n    :doc \"Executes a datalog query. See [docs.datomic.com/on-prem/query.html](https://docs.datomic.com/on-prem/query.html).\n\n          Usage:\n          \n          ```\n          (q '[:find ?value\n               :where [_ :likes ?value]]\n             db)\n          ; => #{[\\\"fries\\\"] [\\\"candy\\\"] [\\\"pie\\\"] [\\\"pizza\\\"]}\n          ```\"}\n  q dq/q)\n\n\n; Creating DB\n\n(defn- maybe-adapt-storage [opts]\n  #?(:clj\n     (if-some [storage (:storage opts)]\n       (update opts :storage storage/make-storage-adapter opts)\n       opts)\n     :cljs opts))\n\n(defn ^DB empty-db\n  \"Creates an empty database with an optional schema.\n\n   Usage:\n   \n   ```\n   (empty-db) ; => #datascript/DB {:schema {}, :datoms []}\n\n   (empty-db {:likes {:db/cardinality :db.cardinality/many}})\n   ; => #datascript/DB {:schema {:likes {:db/cardinality :db.cardinality/many}}\n   ;                    :datoms []}\n   ```\n   \n   Options are:\n   \n   :branching-factor <int>, default 512. B-tree max node length\n   :ref-type         :strong | :soft | :weak, default :soft. How will nodes that are already\n                     stored on disk be referenced. Soft or weak means they might be unloaded\n                     from memory under memory pressure and later fetched from storage again.\n   :storage          <IStorage>. Will be used to store this db later with `(d/store db)`\"\n  ([]\n   (db/empty-db nil {}))\n  ([schema]\n   (db/empty-db schema {}))\n  ([schema opts]\n   (db/empty-db schema (maybe-adapt-storage opts))))\n\n(def ^{:arglists '([x])\n       :doc \"Returns `true` if the given value is an immutable database, `false` otherwise.\"}\n  db? db/db?)\n\n(def ^{:tag Datom\n       :arglists '([e a v] [e a v tx] [e a v tx added])\n       :doc \"Low-level fn to create raw datoms.\n\n             Optionally with transaction id (number) and `added` flag (`true` for addition, `false` for retraction).\n\n             See also [[init-db]].\"}\n  datom db/datom)\n\n(def ^{:arglists '([x])\n       :doc \"Returns `true` if the given value is a datom, `false` otherwise.\"}\n  datom? db/datom?)\n\n(defn ^DB init-db\n  \"Low-level fn for creating database quickly from a trusted sequence of datoms.\n   Does no validation on inputs, so `datoms` must be well-formed and match schema.\n   Used internally in db (de)serialization. See also [[datom]].\n   For options, see [[empty-db]]\"\n  ([datoms]\n   (db/init-db datoms nil {}))\n  ([datoms schema]\n   (db/init-db datoms schema {}))\n  ([datoms schema opts]\n   (db/init-db datoms schema (maybe-adapt-storage opts))))\n\n(def ^{:arglists '([db] [db opts])\n       :doc \"Converts db into a data structure (not string!) that can be fed to serializer\n             of your choice (e.g. `js/JSON.stringify` in CLJS, `cheshire.core/generate-string`\n             or `jsonista.core/write-value-as-string` in CLJ).\n\n             On JVM, `serializable` holds a global lock that prevents any two serializations\n             to run in parallel (an implementation constraint, be aware).\n\n             Options:\n\n             `:freeze-fn` Non-primitive values will be serialized using this. Optional.\n             `pr-str` by default.\"}\n  serializable ds/serializable)\n\n(def ^{:tag DB\n       :arglists '([serializable] [serializable opts])\n       :doc \"Creates db from a data structure (not string!) produced by serializable.\n\n             Opts:\n\n             `:thaw-fn` Non-primitive values will be deserialized using this.\n             Must match :freeze-fn from serializable. Optional. `clojure.edn/read-string`\n             by default.\"}\n  from-serializable ds/from-serializable)\n\n\n; Schema\n\n(def ^{:arglists '([db])\n       :doc \"Returns a schema of a database.\"}\n  schema db/-schema)\n\n\n; Filtered db\n\n(defn is-filtered\n  \"Returns `true` if this database was filtered using [[filter]], `false` otherwise.\"\n  [x]\n  (instance? FilteredDB x))\n\n(defn filter\n  \"Returns a view over database that has same interface but only includes datoms for which the `(pred db datom)` is true. Can be applied multiple times.\n   \n   Filtered DB gotchas:\n\n   - All operations on filtered database are proxied to original DB, then filter pred is applied.\n   - Not cached. You pay filter penalty every time.\n   - Supports entities, pull, queries, index access.\n   - Does not support [[with]] and [[db-with]].\"\n  [db pred]\n  {:pre [(db/db? db)]}\n  (if (is-filtered db)\n    (let [^FilteredDB fdb db\n          orig-pred (.-pred fdb)\n          orig-db   (.-unfiltered-db fdb)]\n      (FilteredDB. orig-db #(and (orig-pred %) (pred orig-db %)) (atom 0)))\n    (FilteredDB. db #(pred db %) (atom 0))))\n\n\n; Changing DB\n\n(defn with\n  \"Same as [[transact!]], but applies to an immutable database value. Returns transaction report (see [[transact!]]).\"\n  ([db tx-data] (with db tx-data nil))\n  ([db tx-data tx-meta]\n   {:pre [(db/db? db)]}\n   (if (is-filtered db)\n     (throw (ex-info \"Filtered DB cannot be modified\" {:error :transaction/filtered}))\n     (db/transact-tx-data (db/->TxReport db db [] {} tx-meta) tx-data))))\n\n(defn ^DB db-with\n  \"Applies transaction to an immutable db value, returning new immutable db value. Same as `(:db-after (with db tx-data))`.\"\n  [db tx-data]\n  {:pre [(db/db? db)]}\n  (:db-after (with db tx-data)))\n\n(defn ^DB with-schema\n  \"Warning! No validation or conversion. Only change schema in a compatible way\"\n  [db schema]\n  (db/with-schema db schema))\n\n; Index lookups\n\n(defn datoms\n  \"Index lookup. Returns a sequence of datoms (lazy iterator over actual DB index) which components (e, a, v) match passed arguments.\n\n   Datoms are sorted in index sort order. Possible `index` values are: `:eavt`, `:aevt`, `:avet`.\n\n   Usage:\n\n       ; find all datoms for entity id == 1 (any attrs and values)\n       ; sort by attribute, then value\n       (datoms db :eavt 1)\n       ; => (#datascript/Datom [1 :friends 2]\n       ;     #datascript/Datom [1 :likes \\\"fries\\\"]\n       ;     #datascript/Datom [1 :likes \\\"pizza\\\"]\n       ;     #datascript/Datom [1 :name \\\"Ivan\\\"])\n  \n       ; find all datoms for entity id == 1 and attribute == :likes (any values)\n       ; sorted by value\n       (datoms db :eavt 1 :likes)\n       ; => (#datascript/Datom [1 :likes \\\"fries\\\"]\n       ;     #datascript/Datom [1 :likes \\\"pizza\\\"])\n       \n       ; find all datoms for entity id == 1, attribute == :likes and value == \\\"pizza\\\"\n       (datoms db :eavt 1 :likes \\\"pizza\\\")\n       ; => (#datascript/Datom [1 :likes \\\"pizza\\\"])\n  \n       ; find all datoms for attribute == :likes (any entity ids and values)\n       ; sorted by entity id, then value\n       (datoms db :aevt :likes)\n       ; => (#datascript/Datom [1 :likes \\\"fries\\\"]\n       ;     #datascript/Datom [1 :likes \\\"pizza\\\"]\n       ;     #datascript/Datom [2 :likes \\\"candy\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pie\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pizza\\\"])\n  \n       ; find all datoms that have attribute == `:likes` and value == `\\\"pizza\\\"` (any entity id)\n       ; `:likes` must be a unique attr, reference or marked as `:db/index true`\n       (datoms db :avet :likes \\\"pizza\\\")\n       ; => (#datascript/Datom [1 :likes \\\"pizza\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pizza\\\"])\n  \n       ; find all datoms sorted by entity id, then attribute, then value\n       (datoms db :eavt) ; => (...)\n\n   Useful patterns:\n\n       ; get all values of :db.cardinality/many attribute\n       (->> (datoms db :eavt eid attr) (map :v))\n  \n       ; lookup entity ids by attribute value\n       (->> (datoms db :avet attr value) (map :e))\n  \n       ; find all entities with a specific attribute\n       (->> (datoms db :aevt attr) (map :e))\n  \n       ; find “singleton” entity by its attr\n       (->> (datoms db :aevt attr) first :e)\n  \n       ; find N entities with lowest attr value (e.g. 10 earliest posts)\n       (->> (datoms db :avet attr) (take N))\n  \n       ; find N entities with highest attr value (e.g. 10 latest posts)\n       (->> (datoms db :avet attr) (reverse) (take N))\n\n   Gotchas:\n   \n   - Index lookup is usually more efficient than doing a query with a single clause.\n   - Resulting iterator is calculated in constant time and small constant memory overhead.\n   - Iterator supports efficient `first`, `next`, `reverse`, `seq` and is itself a sequence.\n   - Will not return datoms that are not part of the index (e.g. attributes with no `:db/index` in schema when querying `:avet` index).\n     - `:eavt` and `:aevt` contain all datoms.\n     - `:avet` only contains datoms for references, `:db/unique` and `:db/index` attributes.\"\n  ([db index]             {:pre [(db/db? db)]} (db/-datoms db index nil nil nil nil))\n  ([db index c0]          {:pre [(db/db? db)]} (db/-datoms db index c0  nil nil nil))\n  ([db index c0 c1]       {:pre [(db/db? db)]} (db/-datoms db index c0  c1  nil nil))\n  ([db index c0 c1 c2]    {:pre [(db/db? db)]} (db/-datoms db index c0  c1  c2  nil))\n  ([db index c0 c1 c2 c3] {:pre [(db/db? db)]} (db/-datoms db index c0  c1  c2  c3)))\n\n(defn ^Datom find-datom\n  \"Same as [[datoms]], but only returns single datom. Faster than `(first (datoms ...))`\"\n  ([db index]             {:pre [(db/db? db)]} (db/find-datom db index nil nil nil nil))\n  ([db index c0]          {:pre [(db/db? db)]} (db/find-datom db index c0  nil nil nil))\n  ([db index c0 c1]       {:pre [(db/db? db)]} (db/find-datom db index c0  c1  nil nil))\n  ([db index c0 c1 c2]    {:pre [(db/db? db)]} (db/find-datom db index c0  c1  c2  nil))\n  ([db index c0 c1 c2 c3] {:pre [(db/db? db)]} (db/find-datom db index c0  c1  c2  c3)))\n\n(defn seek-datoms\n  \"Similar to [[datoms]], but will return datoms starting from specified components and including rest of the database until the end of the index.\n\n   If no datom matches passed arguments exactly, iterator will start from first datom that could be considered “greater” in index order.\n\n   Usage:\n\n       (seek-datoms db :eavt 1)\n       ; => (#datascript/Datom [1 :friends 2]\n       ;     #datascript/Datom [1 :likes \\\"fries\\\"]\n       ;     #datascript/Datom [1 :likes \\\"pizza\\\"]\n       ;     #datascript/Datom [1 :name \\\"Ivan\\\"]\n       ;     #datascript/Datom [2 :likes \\\"candy\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pie\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pizza\\\"])\n\n       (seek-datoms db :eavt 1 :name)\n       ; => (#datascript/Datom [1 :name \\\"Ivan\\\"]\n       ;     #datascript/Datom [2 :likes \\\"candy\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pie\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pizza\\\"])\n  \n       (seek-datoms db :eavt 2) \n       ; => (#datascript/Datom [2 :likes \\\"candy\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pie\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pizza\\\"])\n  \n       ; no datom [2 :likes \\\"fish\\\"], so starts with one immediately following such in index\n       (seek-datoms db :eavt 2 :likes \\\"fish\\\")\n       ; => (#datascript/Datom [2 :likes \\\"pie\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pizza\\\"])\"\n  ([db index]             {:pre [(db/db? db)]} (db/-seek-datoms db index nil nil nil nil))\n  ([db index c0]          {:pre [(db/db? db)]} (db/-seek-datoms db index c0  nil nil nil))\n  ([db index c0 c1]       {:pre [(db/db? db)]} (db/-seek-datoms db index c0  c1  nil nil))\n  ([db index c0 c1 c2]    {:pre [(db/db? db)]} (db/-seek-datoms db index c0  c1  c2  nil))\n  ([db index c0 c1 c2 c3] {:pre [(db/db? db)]} (db/-seek-datoms db index c0  c1  c2  c3)))\n\n(defn rseek-datoms\n  \"Same as [[seek-datoms]], but goes backwards until the beginning of the index.\"\n  ([db index]             {:pre [(db/db? db)]} (db/-rseek-datoms db index nil nil nil nil))\n  ([db index c0]          {:pre [(db/db? db)]} (db/-rseek-datoms db index c0  nil nil nil))\n  ([db index c0 c1]       {:pre [(db/db? db)]} (db/-rseek-datoms db index c0  c1  nil nil))\n  ([db index c0 c1 c2]    {:pre [(db/db? db)]} (db/-rseek-datoms db index c0  c1  c2  nil))\n  ([db index c0 c1 c2 c3] {:pre [(db/db? db)]} (db/-rseek-datoms db index c0  c1  c2  c3)))\n\n(defn index-range\n  \"Returns part of `:avet` index between `[_ attr start]` and `[_ attr end]` in AVET sort order.\n  \n   Same properties as [[datoms]].\n   \n   `attr` must be a reference, unique attribute or marked as `:db/index true`.\n   \n   Usage:\n\n       (index-range db :likes \\\"a\\\" \\\"zzzzzzzzz\\\")\n       ; => (#datascript/Datom [2 :likes \\\"candy\\\"]\n       ;     #datascript/Datom [1 :likes \\\"fries\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pie\\\"]\n       ;     #datascript/Datom [1 :likes \\\"pizza\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pizza\\\"])\n        \n       (index-range db :likes \\\"egg\\\" \\\"pineapple\\\")\n       ; => (#datascript/Datom [1 :likes \\\"fries\\\"]\n       ;     #datascript/Datom [2 :likes \\\"pie\\\"])\n           \n   Useful patterns:\n     \n       ; find all entities with age in a specific range (inclusive)\n       (->> (index-range db :age 18 60) (map :e))\"\n  [db attr start end]\n  {:pre [(db/db? db)]}\n  (db/-index-range db attr start end))\n\n\n;; Conn\n\n(defn conn?\n  \"Returns `true` if this is a connection to a DataScript db, `false` otherwise.\"\n  [conn]\n  (and #?(:clj  (instance? clojure.lang.IDeref conn)\n          :cljs (satisfies? cljs.core/IDeref conn))\n    (db/db? @conn)))\n\n(defn conn-from-db\n  \"Creates a mutable reference to a given immutable database. See [[create-conn]].\"\n  [db]\n  {:pre [(db/db? db)]}\n  (if-some [storage (storage/storage db)]\n    (do\n      (storage/store db)\n      (atom db \n        :meta {:listeners      (atom {})\n               :tx-tail        (atom [])\n               :db-last-stored (atom db)}))\n    (atom db\n      :meta {:listeners (atom {})})))\n\n(defn conn-from-datoms\n  \"Creates an empty DB and a mutable reference to it. See [[create-conn]].\"\n  ([datoms]\n   (conn-from-db (init-db datoms)))\n  ([datoms schema]\n   (conn-from-db (init-db datoms schema)))\n  ([datoms schema opts]\n   (conn-from-db (init-db datoms schema opts))))\n\n(defn create-conn\n  \"Creates a mutable reference (a “connection”) to an empty immutable database.\n\n   Connections are lightweight in-memory structures (~atoms) with direct support of transaction listeners ([[listen!]], [[unlisten!]]) and other handy DataScript APIs ([[transact!]], [[reset-conn!]], [[db]]).\n\n   To access underlying immutable DB value, deref: `@conn`.\n   \n   For list of options, see [[empty-db]].\n   \n   If you specify `:storage` option, conn will be stored automatically after each transaction\"\n  ([]\n   (conn-from-db (empty-db)))\n  ([schema]\n   (conn-from-db (empty-db schema)))\n  ([schema opts]\n   (conn-from-db (empty-db schema opts))))\n\n#?(:clj\n   (defn restore-conn\n     \"Lazy-load database from storage and make conn out of it.\n      Returns nil if there’s no database yet in storage\"\n     ([storage]\n      (restore-conn storage {}))\n     ([storage opts]\n      (when-some [[db tail] (storage/restore-impl storage opts)]\n        (atom (storage/db-with-tail db tail)\n          :meta {:listeners      (atom {})\n                 :tx-tail        (atom tail)\n                 :db-last-stored (atom db)})))))\n\n(defn ^:no-doc -transact! [conn tx-data tx-meta]\n  {:pre [(conn? conn)]}\n  (let [*report (atom nil)]\n    (swap! conn\n      (fn [db]\n        (let [r (with db tx-data tx-meta)]\n          (reset! *report r)\n          (:db-after r))))\n    #?(:clj\n       (when-some [storage (storage/storage @conn)]\n         (let [{db     :db-after\n                datoms :tx-data} @*report\n               settings (set/settings (:eavt db))\n               *tx-tail (:tx-tail (meta conn))\n               tx-tail' (swap! *tx-tail conj datoms)]\n           (if (> (transduce (map count) + 0 tx-tail') (:branching-factor settings))\n             ;; overflow tail\n             (do\n               (storage/store-impl! db (storage/storage-adapter db) false)\n               (reset! *tx-tail [])\n               (reset! (:db-last-stored (meta conn)) db))\n             ;; just update tail\n             (storage/store-tail db tx-tail')))))\n    @*report))\n\n(defn transact!\n  \"Applies transaction the underlying database value and atomically updates connection reference to point to the result of that transaction, new db value.\n  \n   Returns transaction report, a map:\n\n       { :db-before ...       ; db value before transaction\n         :db-after  ...       ; db value after transaction\n         :tx-data   [...]     ; plain datoms that were added/retracted from db-before\n         :tempids   {...}     ; map of tempid from tx-data => assigned entid in db-after\n         :tx-meta   tx-meta } ; the exact value you passed as `tx-meta`\n\n  Note! `conn` will be updated in-place and is not returned from [[transact!]].\n  \n  Usage:\n\n      ; add a single datom to an existing entity (1)\n      (transact! conn [[:db/add 1 :name \\\"Ivan\\\"]])\n  \n      ; retract a single datom\n      (transact! conn [[:db/retract 1 :name \\\"Ivan\\\"]])\n  \n      ; retract single entity attribute\n      (transact! conn [[:db.fn/retractAttribute 1 :name]])\n  \n      ; ... or equivalently (since Datomic changed its API to support this):\n      (transact! conn [[:db/retract 1 :name]])\n      \n      ; retract all entity attributes (effectively deletes entity)\n      (transact! conn [[:db.fn/retractEntity 1]])\n  \n      ; create a new entity (`-1`, as any other negative value, is a tempid\n      ; that will be replaced with DataScript to a next unused eid)\n      (transact! conn [[:db/add -1 :name \\\"Ivan\\\"]])\n  \n      ; check assigned id (here `*1` is a result returned from previous `transact!` call)\n      (def report *1)\n      (:tempids report) ; => {-1 296}\n  \n      ; check actual datoms inserted\n      (:tx-data report) ; => [#datascript/Datom [296 :name \\\"Ivan\\\"]]\n  \n      ; tempid can also be a string\n      (transact! conn [[:db/add \\\"ivan\\\" :name \\\"Ivan\\\"]])\n      (:tempids *1) ; => {\\\"ivan\\\" 297}\n  \n      ; reference another entity (must exist)\n      (transact! conn [[:db/add -1 :friend 296]])\n  \n      ; create an entity and set multiple attributes (in a single transaction\n      ; equal tempids will be replaced with the same yet unused entid)\n      (transact! conn [[:db/add -1 :name \\\"Ivan\\\"]\n                       [:db/add -1 :likes \\\"fries\\\"]\n                       [:db/add -1 :likes \\\"pizza\\\"]\n                       [:db/add -1 :friend 296]])\n  \n      ; create an entity and set multiple attributes (alternative map form)\n      (transact! conn [{:db/id  -1\n                        :name   \\\"Ivan\\\"\n                        :likes  [\\\"fries\\\" \\\"pizza\\\"]\n                        :friend 296}])\n      \n      ; update an entity (alternative map form). Can’t retract attributes in\n      ; map form. For cardinality many attrs, value (fish in this example)\n      ; will be added to the list of existing values\n      (transact! conn [{:db/id  296\n                        :name   \\\"Oleg\\\"\n                        :likes  [\\\"fish\\\"]}])\n\n      ; ref attributes can be specified as nested map, that will create nested entity as well\n      (transact! conn [{:db/id  -1\n                        :name   \\\"Oleg\\\"\n                        :friend {:db/id -2\n                                 :name \\\"Sergey\\\"}}])\n                                 \n      ; reverse attribute name can be used if you want created entity to become\n      ; a value in another entity reference\n      (transact! conn [{:db/id  -1\n                        :name   \\\"Oleg\\\"\n                        :_friend 296}])\n      ; equivalent to\n      (transact! conn [{:db/id  -1, :name   \\\"Oleg\\\"}\n                       {:db/id 296, :friend -1}])\n      ; equivalent to\n      (transact! conn [[:db/add  -1 :name   \\\"Oleg\\\"]\n                       [:db/add 296 :friend -1]])\"\n  ([conn tx-data] (transact! conn tx-data nil))\n  ([conn tx-data tx-meta]\n   {:pre [(conn? conn)]}\n   (let [report (-transact! conn tx-data tx-meta)]\n     (doseq [[_ callback] (some-> (:listeners (meta conn)) (deref))]\n       (callback report))\n     report)))\n\n(defn reset-conn!\n  \"Forces underlying `conn` value to become `db`. Will generate a tx-report that will remove everything from old value and insert everything from the new one.\"\n  ([conn db]\n   (reset-conn! conn db nil))\n  ([conn db tx-meta]\n   {:pre [(conn? conn)\n          (db/db? db)]}\n   (let [db-before @conn\n         report    (db/map->TxReport\n                     {:db-before db-before\n                      :db-after  db\n                      :tx-data   (concat\n                                   (map #(assoc % :added false) (datoms db-before :eavt))\n                                   (datoms db :eavt))\n                      :tx-meta   tx-meta})]\n     #?(:clj\n        (when-some [storage (storage/storage db-before)]\n          (storage/store db)\n          (reset! (:tx-tail (meta conn)) [])\n          (reset! (:db-last-stored (meta conn)) db)))\n     (reset! conn db)\n     (doseq [[_ callback] (some-> (:listeners (meta conn)) (deref))]\n       (callback report))\n     db)))\n\n(defn reset-schema! [conn schema]\n  \"Warning! Does not perform any validation or data conversion. Only change schema in a compatible way\"\n  {:pre [(conn? conn)]}\n  (let [db (swap! conn db/with-schema schema)]\n    #?(:clj\n       (when-some [storage (storage/storage @conn)]\n         (storage/store-impl! db (storage/storage-adapter db) true)\n         (reset! (:tx-tail (meta conn)) [])\n         (reset! (:db-last-stored (meta conn)) db)))\n    db))\n\n(defn- atom? [a]\n  #?(:cljs (instance? Atom a)\n     :clj  (instance? clojure.lang.IAtom a)))\n\n(defn listen!\n  \"Listen for changes on the given connection. Whenever a transaction is applied to the database via [[transact!]], the callback is called\n   with the transaction report. `key` is any opaque unique value.\n   \n   Idempotent. Calling [[listen!]] with the same key twice will override old callback with the new value.\n   \n   Returns the key under which this listener is registered. See also [[unlisten!]].\"\n  ([conn callback]\n   (listen! conn (rand) callback))\n  ([conn key callback]\n   {:pre [(conn? conn)\n          (atom? (:listeners (meta conn)))]}\n   (swap! (:listeners (meta conn)) assoc key callback)\n   key))\n\n(defn unlisten!\n  \"Removes registered listener from connection. See also [[listen!]].\"\n  [conn key]\n  {:pre [(conn? conn)\n         (atom? (:listeners (meta conn)))]}\n  (swap! (:listeners (meta conn)) dissoc key))\n\n\n; Data Readers\n\n(def ^{:doc \"Data readers for EDN readers. In CLJS they’re registered automatically. In CLJ, if `data_readers.clj` do not work, you can always do\n\n             ```\n             (clojure.edn/read-string {:readers data-readers} \\\"...\\\")\n             ```\"}\n  data-readers {'datascript/Datom db/datom-from-reader\n                'datascript/DB    db/db-from-reader})\n\n#?(:cljs\n   (doseq [[tag cb] data-readers] (edn/register-tag-parser! tag cb)))\n\n\n;; Datomic compatibility layer\n\n(def ^:private last-tempid (atom -1000000))\n\n(defn tempid\n  \"Allocates and returns an unique temporary id (a negative integer). Ignores `part`. Returns `x` if it is specified.\n  \n   Exists for Datomic API compatibility. Prefer using negative integers directly if possible.\"\n  ([part]\n   (if (= part :db.part/tx)\n     :db/current-tx\n     (swap! last-tempid dec)))\n  ([part x]\n   (if (= part :db.part/tx)\n     :db/current-tx\n     x)))\n\n(defn resolve-tempid\n  \"Does a lookup in tempids map, returning an entity id that tempid was resolved to.\n   \n   Exists for Datomic API compatibility. Prefer using map lookup directly if possible.\"\n  [_db tempids tempid]\n  (get tempids tempid))\n\n(defn ^DB db\n  \"Returns the underlying immutable database value from a connection.\n   \n   Exists for Datomic API compatibility. Prefer using `@conn` directly if possible.\"\n  [conn]\n  {:pre [(conn? conn)]}\n  @conn)\n\n(defn transact\n  \"Same as [[transact!]], but returns an immediately realized future.\n  \n   Exists for Datomic API compatibility. Prefer using [[transact!]] if possible.\"\n  ([conn tx-data] (transact conn tx-data nil))\n  ([conn tx-data tx-meta]\n   {:pre [(conn? conn)]}\n   (let [res (transact! conn tx-data tx-meta)]\n     #?(:cljs\n        (reify\n          IDeref\n          (-deref [_] res)\n          IDerefWithTimeout\n          (-deref-with-timeout [_ _ _] res)\n          IPending\n          (-realized? [_] true))\n        :clj\n        (reify\n          clojure.lang.IDeref\n          (deref [_] res)\n          clojure.lang.IBlockingDeref\n          (deref [_ _ _] res)\n          clojure.lang.IPending\n          (isRealized [_] true))))))\n\n\n;; ersatz future without proper blocking\n#?(:cljs\n   (defn- future-call [f]\n     (let [res      (atom nil)\n           realized (atom false)]\n       (js/setTimeout #(do (reset! res (f)) (reset! realized true)) 0)\n       (reify\n         IDeref\n         (-deref [_] @res)\n         IDerefWithTimeout\n         (-deref-with-timeout [_ _ timeout-val] (if @realized @res timeout-val))\n         IPending\n         (-realized? [_] @realized)))))\n\n(defn transact-async\n  \"In CLJ, calls [[transact!]] on a future thread pool, returning immediately.\n  \n   In CLJS, just calls [[transact!]] and returns a realized future.\"\n  ([conn tx-data] (transact-async conn tx-data nil))\n  ([conn tx-data tx-meta]\n   {:pre [(conn? conn)]}\n   (future-call #(transact! conn tx-data tx-meta))))\n\n\n;; squuid\n\n(def ^{:arglists '([] [msec])} squuid\n  \"Generates a UUID that grow with time. Such UUIDs will always go to the end  of the index and that will minimize insertions in the middle.\n  \n   Consist of 64 bits of current UNIX timestamp (in seconds) and 64 random bits (2^64 different unique values per second).\"\n  util/squuid)\n\n(def ^{:arglists '([uuid])} squuid-time-millis\n  \"Returns time that was used in [[squuid]] call, in milliseconds, rounded to the closest second.\"\n  util/squuid-time-millis)\n\n\n;; Storage\n#?(:clj\n   (def ^{:arglists '([db])} storage\n     \"Returns IStorage used by DB instance\"\n     storage/storage))\n\n#?(:clj\n   (def ^{:arglists '([db] [db storage])} store\n     \"Stores databases to provided storage. If database was created\n      with :storage option or restored from storage, use single-argument version.\n      \n      Subsequent stores are incremental, i.e. only newly added nodes will be actually stored.\n      \n      Storing already stored dbs into another storage is not supported (may change).\"\n     storage/store))\n\n#?(:clj \n   (def ^{:arglists '([storage] [storage opts])} restore\n     \"Lazy-loads database from storage. Ultra-fast, fetches the rest as it’s needed\"\n     storage/restore))\n\n#?(:clj\n   (defn addresses\n     \"Returns all addresses in use by current db (as java.util.HashSet).\n      Anything that is not in the return set is safe to be deleted\"\n     [& dbs]\n     (storage/addresses dbs)))\n\n#?(:clj\n   (def ^{:arglists '([storage])} collect-garbage\n     \"Deletes all keys from storage that are not referenced by any of the currently alive db refs.\n      Has a side-effect of fully loading databases fully into memory, so, can be slow\"\n     storage/collect-garbage))\n\n#?(:clj\n   (def ^{:arglists '([dir] [dir opts])} file-storage\n     \"Default implementation that stores data in files in a dir.\n   \n   Options are:\n   \n   :freeze-fn :: (data)   -> String. A serialization function\n   :thaw-fn   :: (String) -> data. A deserialization function\n   :write-fn  :: (OutputStream data) -> void. Implement your own writer to FileOutputStream\n   :read-fn   :: (InputStream) -> Object. Implement your own reader from FileInputStream\n   :addr->filename-fn :: (UUID) -> String. Construct file name from address\n   :filename->addr-fn :: (String) -> UUID. Reconstruct address from file name\n   \n   All options are optional.\"\n     storage/file-storage))\n\n(defn settings [db]\n  (set/settings (:eavt db)))\n","~:reader-features",["^H",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["datascript.core/tx0","datascript.db/tx0","datascript.core/entity","datascript.impl.entity/entity","datascript.core/entid","datascript.db/entid","js/Error","datascript.core/entity-db","entity","datascript.impl.entity/entity?","datascript.core/touch","datascript.impl.entity/touch","datascript.core/pull","datascript.pull-api/pull","datascript.core/pull-many","datascript.pull-api/pull-many","datascript.core/q","datascript.query/q","datascript.core/maybe-adapt-storage","opts","var_args","G__23678","datascript.core/empty-db","datascript.db/empty-db","schema","datascript.core/db?","datascript.db/db?","datascript.core/datom","datascript.db/datom","datascript.core/datom?","datascript.db/datom?","G__23681","datascript.core/init-db","datoms","datascript.db/init-db","datascript.core/serializable","datascript.serialize/serializable","datascript.core/from-serializable","datascript.serialize/from-serializable","datascript.core/schema","datascript.db/-schema","datascript.core/is-filtered","x","datascript.db/FilteredDB","datascript.core/filter","db","pred","fdb","orig-pred","orig-db","p1__23683#","and__5043__auto__","cljs.core.atom","p1__23684#","G__23686","datascript.core/with","tx-data","datascript.core.with$","tx-meta","cljs.core.ex_info","datascript.db/transact-tx-data","datascript.db/->TxReport","datascript.core/db-with","datascript.core/with-schema","datascript.db/with-schema","G__23696","datascript.core/datoms","index","datascript.db/-datoms","c0","c1","c2","c3","G__23704","datascript.core/find-datom","datascript.db/find-datom","G__23733","datascript.core/seek-datoms","datascript.db/-seek-datoms","G__23736","datascript.core/rseek-datoms","datascript.db/-rseek-datoms","datascript.core/index-range","attr","start","end","datascript.db/-index-range","datascript.core/conn?","conn","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/IDeref","cljs.core/deref","datascript.core/conn-from-db","temp__5806__auto__","storage","datascript.storage/storage","datascript.storage.store","G__23742","datascript.core/conn-from-datoms","datascript.core.init_db","G__23750","datascript.core/create-conn","datascript.core.empty_db","datascript.core/-transact!","*report","cljs.core.swap_BANG_","r","cljs.core/reset!","G__23770","datascript.core/transact!","datascript.core.transact_BANG_","report","seq__23771","cljs.core/seq","chunk__23772","count__23773","i__23774","vec__23784","cljs.core.nth","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","vec__23789","cljs.core/first","cljs.core/next","_","callback","G__23782","cljs.core/meta","G__23794","datascript.core/reset-conn!","datascript.core.reset_conn_BANG_","db-before","datascript.db/map->TxReport","cljs.core.concat","p1__23792#","cljs.core.map","cljs.core.assoc","datascript.core.datoms","seq__23795","chunk__23796","count__23797","i__23798","vec__23808","vec__23811","G__23807","datascript.core/reset-schema!","datascript.core/atom?","a","cljs.core/Atom","G__23816","datascript.core/listen!","datascript.core.listen_BANG_","cljs.core.rand","key","cljs.core/assoc","datascript.core/unlisten!","cljs.core/dissoc","datascript.core/data-readers","datascript.db/datom-from-reader","datascript.db/db-from-reader","seq__23823","chunk__23824","count__23825","i__23826","vec__23835","vec__23839","tag","cb","cljs.reader/register-tag-parser!","datascript.core/last-tempid","G__23843","datascript.core/tempid","part","cljs.core._EQ_","cljs.core/dec","datascript.core/resolve-tempid","_db","tempids","tempid","cljs.core.get","datascript.core/db","G__23845","datascript.core/transact","datascript.core.transact","res","datascript.core/t_datascript$core23848","datascript.core/future-call","f","realized","js/setTimeout","datascript.core/t_datascript$core23866","timeout-val","G__23873","datascript.core/transact-async","datascript.core.transact_async","datascript.core/squuid","datascript.util/squuid","datascript.core/squuid-time-millis","datascript.util/squuid-time-millis","datascript.core/settings","me.tonsky.persistent-sorted-set/settings"]],"~:used-vars",["^H",["~$datascript.core/schema","~$cljs.core/PROTOCOL_SENTINEL","~$datascript.core/index-range","~$datascript.core/filter","~$datascript.core/last-tempid","~$datascript.core/from-serializable","~$datascript.core/squuid","~$datascript.db/empty-db","~$datascript.core/with","~$datascript.pull-api/pull-many","~$cljs.core/=","~$datascript.core/reset-conn!","~$datascript.core/db?","~$cljs.core/dec","~$datascript.db/map->TxReport","~$datascript.core/tempid","~$datascript.core/entity-db","~$datascript.db/db?","~$datascript.db/-schema","~$datascript.core/create-conn","~$datascript.serialize/serializable","~$cljs.core/-write","~$datascript.util/squuid","~$datascript.core/transact-async","~$datascript.db/tx0","~$cljs.core/count","~$cljs.core/deref","~$datascript.core/tx0","~$cljs.core/seq","~$cljs.core/chunk-first","~$datascript.db/->TxReport","~$datascript.core/find-datom","~$cljs.core/rand","~$cljs.core/dissoc","~$datascript.impl.entity/entity?","~$cljs.core/chunk-rest","~$cljs.core/atom","~$datascript.core/t_datascript$core23848","~$datascript.core/settings","~$cljs.core/concat","~$datascript.core/pull","~$datascript.core/listen!","~$datascript.core/entity","~$datascript.storage/store","~$datascript.core/conn-from-datoms","~$datascript.impl.entity/entity","~$datascript.db/find-datom","~$js/setTimeout","~$datascript.core/datom?","~$datascript.core/conn-from-db","~$cljs.core/native-satisfies?","~$datascript.db/init-db","~$datascript.core/init-db","~$cljs.core/reset!","~$datascript.db/datom?","~$datascript.db/datom-from-reader","~$cljs.core/map","~$datascript.core/reset-schema!","~$datascript.serialize/from-serializable","~$datascript.db/FilteredDB","~$me.tonsky.persistent-sorted-set/settings","~$datascript.core/q","~$datascript.core/maybe-adapt-storage","~$cljs.core/swap!","~$cljs.reader/register-tag-parser!","~$datascript.core/pull-many","~$datascript.core/seek-datoms","~$cljs.core/get","~$datascript.core/transact","~$datascript.core/->t_datascript$core23848","~$datascript.core/unlisten!","~$datascript.core/db-with","~$datascript.core/conn?","~$cljs.core/-nth","~$datascript.db/-datoms","~$datascript.impl.entity/touch","~$datascript.core/with-schema","~$datascript.core/serializable","~$datascript.db/datom","~$datascript.core/touch","~$datascript.db/entid","~$datascript.core/entid","~$datascript.db/with-schema","~$datascript.core/datom","~$datascript.db/-index-range","~$datascript.core/squuid-time-millis","~$cljs.core/nth","~$cljs.core/ex-info","~$cljs.core/meta","~$datascript.core/db","~$datascript.db/db-from-reader","~$datascript.core/data-readers","~$datascript.util/squuid-time-millis","~$cljs.core/next","~$datascript.core/-transact!","~$cljs.core/IDeref","~$cljs.core/not","~$cljs.core/Atom","~$cljs.core/assoc","~$datascript.core/t_datascript$core23866","~$datascript.core/future-call","~$datascript.storage/storage","~$datascript.core/atom?","~$datascript.core/empty-db","~$cljs.core/first","~$datascript.db/-rseek-datoms","~$datascript.core/resolve-tempid","~$datascript.db/transact-tx-data","~$datascript.db/-seek-datoms","~$datascript.core/transact!","~$datascript.core/datoms","~$datascript.core/rseek-datoms","~$js/Error","~$datascript.core/->t_datascript$core23866","~$datascript.core/is-filtered","~$datascript.query/q","~$cljs.core/chunked-seq?","~$datascript.pull-api/pull"]]],"~:cache-keys",["~#cmap",[["^1K","datascript/db.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^H",[]],"~:deps-syms",["^V","^U","~$goog.array","~$clojure.walk","~$clojure.data","~$datascript.lru","^R","~$me.tonsky.persistent-sorted-set.arrays"]]],["^1K","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","~$goog.dom.HtmlElement"]]],["^1K","datascript/parser.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","~$clojure.set","^X"]]],["^1K","datascript/core.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^16","^X","^12","^11","^Z","^S","^14","^T","^R"]]],["^1K","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","~$clojure.string","~$goog.string"]]],["^1K","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.asserts","~$goog.string.internal","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^1K","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^4["]]],["^1K","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z"]]],["^1K","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","datascript/serialize.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","~$clojure.edn","^4V","^X","^4R","^Z","^R","^4S"]]],["^1K","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","~$cljs.tools.reader.impl.errors","~$cljs.tools.reader.reader-types","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^4W","~$goog.string.StringBuffer"]]],["^1K","datascript/query.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^16","^4U","^4V","^4P","~$datascript.built-ins","^X","^4S","^4R","^14","~$datascript.parser","^12"]]],["^1K","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U"]]],["^1K","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4X","^4["]]],["^1K","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^58","^59","^5:","^57","^4O","^4W","^5<"]]],["^1K","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z"]]],"~:SHADOW-TIMESTAMP",[1696742661000,1696742661000,1685338599000],["^1K","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z","~$goog.reflect"]]],["^1K","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z","~$goog.fs.blob","^52","~$goog.html.SafeScript","~$goog.html.trustedtypes","^54","^55"]]],["^1K","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","datascript/pull_api.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^4V","~$datascript.pull-parser","^X","^4R","^R"]]],["^1K","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","datascript/util.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U"]]],["^1K","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^54","~$goog.html.SafeUrl","^55","^4Z","^4["]]],["^1K","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^5B","~$goog.html.SafeStyle","^5E","^53","~$goog.html.uncheckedconversions","^54","^4["]]],["^1K","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","~$goog.dom.TagName","^4Z","~$goog.dom.element"]]],["^1K","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U"]]],["^1K","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^54","^5B","^5J","~$goog.html.SafeStyleSheet","^5E","^5L","^53","^55","^4Z","~$goog.labs.userAgent.browser","^4O","~$goog.object","^4[","~$goog.dom.tags","^5C"]]],["^1K","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^5P"]]],["^1K","datascript/impl/entity.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^X"]]],["^1K","me/tonsky/persistent_sorted_set/arrays.cljc"],["7c8a2fc60577be456d69a471e6da9fa6e36b3cd0","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^4V"]]],["^1K","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","cljs/reader.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^5P","^5;","~$cljs.tools.reader.edn","^5<"]]],["^1K","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1K","me/tonsky/persistent_sorted_set.cljs"],["7c8a2fc60577be456d69a471e6da9fa6e36b3cd0","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^4S"]]],["^1K","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4O","^4Z","~$goog.collections.maps","^4W","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1K","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Y"]]],["^1K","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","clojure/edn.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^16"]]],["^1K","datascript/storage.cljs"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U"]]],["^1K","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",[]]],["^1K","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4O","^5P"]]],["^1K","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^58","^4V","~$cljs.tools.reader.impl.inspect"]]],["^1K","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^4W","^5<"]]],["^1K","datascript/pull_parser.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^5=","^X"]]],["^1K","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","~$goog.dom.safe","^5K","^54","^4["]]],["^1K","clojure/data.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^4U"]]],["^1K","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4[","^51"]]],["^1K","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^59","^4W","^5<"]]],["^1K","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","~$goog.flags"]]],["^1K","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^5T","^5L"]]],["^1K","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z","^5I","^5B","^5J","^5N","^5E","^53","^54","^4["]]],["^1K","datascript/lru.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U"]]],["^1K","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^57","^58","^59"]]],["^1K","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V"]]],["^1K","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","~$goog.math.Long","~$goog.math.Integer","^4W","^5P","^4O","~$goog.Uri","^5<"]]],["^1K","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^54","^55","^5C","^4Z"]]],["^1K","datascript/built_ins.cljc"],["ea08a8bf28b1a0f941624d63fc53b9941874f836","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U","^4V","^X","^14"]]],["^1K","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^54","^5J","^55","^5P","^4Z","^4["]]],["^1K","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^5@"]]],["^1K","clojure/set.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^U"]]],["^1K","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z","^4W"]]],["^1K","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4K",["^ ","^4L",null,"^4M",["^H",[]],"^4N",["^V","^4Z","^55"]]]]],"~:clj-info",["^ ","jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/reader.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/datascript/datascript/1.5.3/datascript-1.5.3.jar!/datascript/serialize.cljc",1696747362000,"jar:file:/home/neromous/.m2/repository/datascript/datascript/1.5.3/datascript-1.5.3.jar!/datascript/parser.cljc",1696747362000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1685338598000,"jar:file:/home/neromous/.m2/repository/datascript/datascript/1.5.3/datascript-1.5.3.jar!/datascript/util.cljc",1696747362000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/datascript/datascript/1.5.3/datascript-1.5.3.jar!/datascript/db.cljc",1696747362000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1685338598000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1685338598000,"jar:file:/home/neromous/.m2/repository/persistent-sorted-set/persistent-sorted-set/0.3.0/persistent-sorted-set-0.3.0.jar!/me/tonsky/persistent_sorted_set/arrays.cljc",1696747361000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/datascript/datascript/1.5.3/datascript-1.5.3.jar!/datascript/lru.cljc",1696747362000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1685338598000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/persistent-sorted-set/persistent-sorted-set/0.3.0/persistent-sorted-set-0.3.0.jar!/me/tonsky/persistent_sorted_set.clj",1696747361000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1685338598000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1685338598000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1685338598000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1685338598000,"jar:file:/home/neromous/.m2/repository/datascript/datascript/1.5.3/datascript-1.5.3.jar!/datascript/storage.clj",1696747362000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1685338599000,"jar:file:/home/neromous/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1685338599000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","datascript/core.cljc","^7",1,"^8",5,"^9",1,"^:",20],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E"],"^F",null,"^G",["^H",["^I"]],"^J","^K","^L",["^ "],"^O",null,"^P",["^ ","^Q","^R","^S","^S","^T","^T","^U","^U","^V","^V","^W","^X","^Y","^T","^Z","^Z","^[","^S","^10","^11","^11","^11","^R","^R","^X","^X","^12","^12","^13","^14","^15","^12","^16","^16","^17","^16","^18","^Z","^14","^14"],"^19",["^H",["^1:"]],"~:shadow/js-access-global",["^H",["Error","setTimeout"]],"^1;",["^ ","^1<","^X","^1=","^X","^1>","^X"],"~:defs",["^ ","~$pull",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",116,"^8",3,"^9",116,"^:",7,"~:arglists",["^1A",["~$quote",["^1A",[["^W","~$selector","~$eid"]]]]],"~:doc","Fetches data from database using recursive declarative description. See [docs.datomic.com/on-prem/pull.html](https://docs.datomic.com/on-prem/pull.html).\n\n             Unlike [[entity]], returns plain Clojure map (not lazy).\n\n             Usage:\n\n                 (pull db [:db/id, :name, :likes, {:friends [:db/id :name]}] 1)\n                 ; => {:db/id   1,\n                 ;     :name    \"Ivan\"\n                 ;     :likes   [:pizza]\n                 ;     :friends [{:db/id 2, :name \"Oleg\"}]}"],"^J","^2S","^6","datascript/core.cljc","^:",7,"^8",1,"~:root-source-info",["^ ","~:source-type","~:fragment","~:source-form",["^1A",["~$def","^73","~$dp/pull"]]],"^7",104,"^9",116,"^74",["^1A",["^75",["^1A",[["^W","^76","^77"]]]]],"^78","Fetches data from database using recursive declarative description. See [docs.datomic.com/on-prem/pull.html](https://docs.datomic.com/on-prem/pull.html).\n\n             Unlike [[entity]], returns plain Clojure map (not lazy).\n\n             Usage:\n\n                 (pull db [:db/id, :name, :likes, {:friends [:db/id :name]}] 1)\n                 ; => {:db/id   1,\n                 ;     :name    \"Ivan\"\n                 ;     :likes   [:pizza]\n                 ;     :friends [{:db/id 2, :name \"Oleg\"}]}"],"~$listen!",["^ ","~:protocol-inline",null,"^5",["^ ","^6","datascript/core.cljc","^7",674,"^8",7,"^9",674,"^:",14,"^74",["^1A",["^75",["^1A",[["~$conn","~$callback"],["^7A","~$key","^7B"]]]]],"^78","Listen for changes on the given connection. Whenever a transaction is applied to the database via [[transact!]], the callback is called\n   with the transaction report. `key` is any opaque unique value.\n   \n   Idempotent. Calling [[listen!]] with the same key twice will override old callback with the new value.\n   \n   Returns the key under which this listener is registered. See also [[unlisten!]].","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",3,"~:max-fixed-arity",3,"~:method-params",[["^7A","^7B"],["^7A","^7C","^7B"]],"^74",["^1A",[["^7A","^7B"],["^7A","^7C","^7B"]]],"~:arglists-meta",["^1A",[null,null]]]],"^J","^2T","^6","datascript/core.cljc","^:",14,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^7B"],["^7A","^7C","^7B"]],"^74",["^1A",[["^7A","^7B"],["^7A","^7C","^7B"]]],"^7I",["^1A",[null,null]]],"^7H",[["^7A","^7B"],["^7A","^7C","^7B"]],"~:protocol-impl",null,"^7F",3,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["~$defn","^7?","Listen for changes on the given connection. Whenever a transaction is applied to the database via [[transact!]], the callback is called\n   with the transaction report. `key` is any opaque unique value.\n   \n   Idempotent. Calling [[listen!]] with the same key twice will override old callback with the new value.\n   \n   Returns the key under which this listener is registered. See also [[unlisten!]].",["^1A",[["^7A","^7B"],["^1A",["^7?","^7A",["^1A",["~$rand"]],"^7B"]]]],["^1A",[["^7A","^7C","^7B"],["^ ","~:pre",[["^1A",["~$conn?","^7A"]],["^1A",["~$atom?",["^1A",["~:listeners",["^1A",["~$meta","^7A"]]]]]]]],["^1A",["~$swap!",["^1A",["^7P",["^1A",["^7Q","^7A"]]]],"~$assoc","^7C","^7B"]],"^7C"]]]]],"^7E",false,"~:methods",[["^ ","^7F",2,"^7E",false,"~:tag","~$any"],["^ ","^7F",3,"^7E",false]],"^7",674,"^9",674,"^7G",3,"~:fn-var",true,"^74",["^1A",[["^7A","^7B"],["^7A","^7C","^7B"]]],"^78","Listen for changes on the given connection. Whenever a transaction is applied to the database via [[transact!]], the callback is called\n   with the transaction report. `key` is any opaque unique value.\n   \n   Idempotent. Calling [[listen!]] with the same key twice will override old callback with the new value.\n   \n   Returns the key under which this listener is registered. See also [[unlisten!]]."],"~$conn-from-datoms",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",477,"^8",7,"^9",477,"^:",23,"^74",["^1A",["^75",["^1A",[["~$datoms"],["^7Y","~$schema"],["^7Y","^7Z","~$opts"]]]]],"^78","Creates an empty DB and a mutable reference to it. See [[create-conn]].","^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]],"^74",["^1A",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]]],"^7I",["^1A",[null,null,null]]]],"^J","^2W","^6","datascript/core.cljc","^:",23,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]],"^74",["^1A",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]]],"^7I",["^1A",[null,null,null]]],"^7H",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]],"^7J",null,"^7F",3,"^7I",["^1A",[null,null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^7X","Creates an empty DB and a mutable reference to it. See [[create-conn]].",["^1A",[["^7Y"],["^1A",["~$conn-from-db",["^1A",["~$init-db","^7Y"]]]]]],["^1A",[["^7Y","^7Z"],["^1A",["^80",["^1A",["^81","^7Y","^7Z"]]]]]],["^1A",[["^7Y","^7Z","^7["],["^1A",["^80",["^1A",["^81","^7Y","^7Z","^7["]]]]]]]]],"^7E",false,"^7T",[["^ ","^7F",1,"^7E",false,"^7U","^44"],["^ ","^7F",2,"^7E",false,"^7U","^44"],["^ ","^7F",3,"^7E",false,"^7U","^44"]],"^7",477,"^9",477,"^7G",3,"^7W",true,"^74",["^1A",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]]],"^78","Creates an empty DB and a mutable reference to it. See [[create-conn]]."],"~$future-call",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",771,"^8",11,"^9",771,"^:",22,"~:private",true,"^74",["^1A",["^75",["^1A",[["~$f"]]]]]],"^83",true,"^J","^47","^6","datascript/core.cljc","^:",22,"^7H",["^1A",[["~$f"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",4,"^79",["^ ","^7:","^7;","^7<",["^1A",["~$defn-","^82",["~$f"],["^1A",["~$let",["~$res",["^1A",["~$atom",null]],"~$realized",["^1A",["^87",false]]],["^1A",["^2Z",["^1A",["~$fn*",[],["^1A",["~$do",["^1A",["~$reset!","^86",["^1A",["~$f"]]]],["^1A",["^8;","^88",true]]]]]],0]],["^1A",["~$reify","~$IDeref",["^1A",["~$-deref",["~$_"],["^1A",["~$clojure.core/deref","^86"]]]],"~$IDerefWithTimeout",["^1A",["~$-deref-with-timeout",["~$_","~$_","~$timeout-val"],["^1A",["~$if",["^1A",["^8?","^88"]],["^1A",["^8?","^86"]],"^8B"]]]],"~$IPending",["^1A",["~$-realized?",["~$_"],["^1A",["^8?","^88"]]]]]]]]]]],"^7E",false,"^7",771,"~:ret-tag","^46","^9",771,"^7G",1,"^7W",true,"^74",["^1A",["^75",["^1A",[["~$f"]]]]]],"~$entity",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",75,"^8",3,"^9",75,"^:",9,"^7U","~$Entity","^74",["^1A",["^75",["^1A",[["^W","^77"]]]]],"^78","Retrieves an entity by its id from database. Entities are lazy map-like structures to navigate DataScript database content.\n\n             For `eid` pass entity id or lookup attr:\n             \n                 (entity db 1)\n                 (entity db [:unique-attr :value])\n            \n             If entity does not exist, `nil` is returned:\n\n                 (entity db 100500) ; => nil\n\n             Creating an entity by id is very cheap, almost no-op, as attr access is on-demand:\n\n                 (entity db 1) ; => {:db/id 1}\n\n             Entity attributes can be lazily accessed through key lookups:\n             \n                 (:attr (entity db 1)) ; => :value\n                 (get (entity db 1) :attr) ; => :value\n\n             Cardinality many attributes are returned sequences:\n\n                 (:attrs (entity db 1)) ; => [:v1 :v2 :v3]\n\n             Reference attributes are returned as another entities:\n\n                 (:ref (entity db 1)) ; => {:db/id 2}\n                 (:ns/ref (entity db 1)) ; => {:db/id 2}\n\n             References can be walked backwards by prepending `_` to name part of an attribute:\n\n                 (:_ref (entity db 2)) ; => [{:db/id 1}]\n                 (:ns/_ref (entity db 2)) ; => [{:db/id 1}]\n             \n             Reverse reference lookup returns sequence of entities unless attribute is marked as `:db/isComponent`:\n\n                 (:_component-ref (entity db 2)) ; => {:db/id 1}\n\n             Entity gotchas:\n               \n             - Entities print as map, but are not exactly maps (they have compatible get interface though).\n             - Entities are effectively immutable “views” into a particular version of a database.\n             - Entities retain reference to the whole database.\n             - You can’t change database through entities, only read.\n             - Creating an entity by id is very cheap, almost no-op (attributes are looked up on demand).\n             - Comparing entities just compares their ids. Be careful when comparing entities taken from different dbs or from different versions of the same db.\n             - Accessed entity attributes are cached on entity itself (except backward references).\n             - When printing, only cached attributes (the ones you have accessed before) are printed. See [[touch]]."],"^J","^2U","^6","datascript/core.cljc","^:",9,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^8G","~$de/entity"]]],"^7",25,"^9",75,"^7U","^8H","^74",["^1A",["^75",["^1A",[["^W","^77"]]]]],"^78","Retrieves an entity by its id from database. Entities are lazy map-like structures to navigate DataScript database content.\n\n             For `eid` pass entity id or lookup attr:\n             \n                 (entity db 1)\n                 (entity db [:unique-attr :value])\n            \n             If entity does not exist, `nil` is returned:\n\n                 (entity db 100500) ; => nil\n\n             Creating an entity by id is very cheap, almost no-op, as attr access is on-demand:\n\n                 (entity db 1) ; => {:db/id 1}\n\n             Entity attributes can be lazily accessed through key lookups:\n             \n                 (:attr (entity db 1)) ; => :value\n                 (get (entity db 1) :attr) ; => :value\n\n             Cardinality many attributes are returned sequences:\n\n                 (:attrs (entity db 1)) ; => [:v1 :v2 :v3]\n\n             Reference attributes are returned as another entities:\n\n                 (:ref (entity db 1)) ; => {:db/id 2}\n                 (:ns/ref (entity db 1)) ; => {:db/id 2}\n\n             References can be walked backwards by prepending `_` to name part of an attribute:\n\n                 (:_ref (entity db 2)) ; => [{:db/id 1}]\n                 (:ns/_ref (entity db 2)) ; => [{:db/id 1}]\n             \n             Reverse reference lookup returns sequence of entities unless attribute is marked as `:db/isComponent`:\n\n                 (:_component-ref (entity db 2)) ; => {:db/id 1}\n\n             Entity gotchas:\n               \n             - Entities print as map, but are not exactly maps (they have compatible get interface though).\n             - Entities are effectively immutable “views” into a particular version of a database.\n             - Entities retain reference to the whole database.\n             - You can’t change database through entities, only read.\n             - Creating an entity by id is very cheap, almost no-op (attributes are looked up on demand).\n             - Comparing entities just compares their ids. Be careful when comparing entities taken from different dbs or from different versions of the same db.\n             - Accessed entity attributes are cached on entity itself (except backward references).\n             - When printing, only cached attributes (the ones you have accessed before) are printed. See [[touch]]."],"^80",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",463,"^8",7,"^9",463,"^:",19,"^74",["^1A",["^75",["^1A",[["^W"]]]]],"^78","Creates a mutable reference to a given immutable database. See [[create-conn]]."],"^J","^30","^6","datascript/core.cljc","^:",19,"^7H",["^1A",[["^W"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^80","Creates a mutable reference to a given immutable database. See [[create-conn]].",["^W"],["^ ","^7M",[["^1A",["~$db/db?","^W"]]]],["^1A",["~$if-some",["^18",["^1A",["~$storage/storage","^W"]]],["^1A",["^8:",["^1A",["~$storage/store","^W"]],["^1A",["^87","^W","^5",["^ ","^7P",["^1A",["^87",["^ "]]],"~:tx-tail",["^1A",["^87",[]]],"~:db-last-stored",["^1A",["^87","^W"]]]]]]],["^1A",["^87","^W","^5",["^ ","^7P",["^1A",["^87",["^ "]]]]]]]]]]],"^7E",false,"^7",463,"^8F","^44","^9",463,"^7G",1,"^7W",true,"^74",["^1A",["^75",["^1A",[["^W"]]]]],"^78","Creates a mutable reference to a given immutable database. See [[create-conn]]."],"^7O",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",670,"^8",8,"^9",670,"^:",13,"^83",true,"^74",["^1A",["^75",["^1A",[["~$a"]]]]]],"^83",true,"^J","^49","^6","datascript/core.cljc","^:",13,"^7H",["^1A",[["~$a"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^84","^7O",["~$a"],["^1A",["~$instance?","~$Atom","~$a"]]]]],"^7E",false,"^7",670,"^8F","~$boolean","^9",670,"^7G",1,"^7W",true,"^74",["^1A",["^75",["^1A",[["~$a"]]]]]],"^7Y",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",295,"^8",7,"^9",295,"^:",13,"^74",["^1A",["^75",["^1A",[["^W","~$index"],["^W","^8S","~$c0"],["^W","^8S","^8T","~$c1"],["^W","^8S","^8T","^8U","~$c2"],["^W","^8S","^8T","^8U","^8V","~$c3"]]]]],"^78","Index lookup. Returns a sequence of datoms (lazy iterator over actual DB index) which components (e, a, v) match passed arguments.\n\n   Datoms are sorted in index sort order. Possible `index` values are: `:eavt`, `:aevt`, `:avet`.\n\n   Usage:\n\n       ; find all datoms for entity id == 1 (any attrs and values)\n       ; sort by attribute, then value\n       (datoms db :eavt 1)\n       ; => (#datascript/Datom [1 :friends 2]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [1 :name \"Ivan\"])\n  \n       ; find all datoms for entity id == 1 and attribute == :likes (any values)\n       ; sorted by value\n       (datoms db :eavt 1 :likes)\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"])\n       \n       ; find all datoms for entity id == 1, attribute == :likes and value == \"pizza\"\n       (datoms db :eavt 1 :likes \"pizza\")\n       ; => (#datascript/Datom [1 :likes \"pizza\"])\n  \n       ; find all datoms for attribute == :likes (any entity ids and values)\n       ; sorted by entity id, then value\n       (datoms db :aevt :likes)\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; find all datoms that have attribute == `:likes` and value == `\"pizza\"` (any entity id)\n       ; `:likes` must be a unique attr, reference or marked as `:db/index true`\n       (datoms db :avet :likes \"pizza\")\n       ; => (#datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; find all datoms sorted by entity id, then attribute, then value\n       (datoms db :eavt) ; => (...)\n\n   Useful patterns:\n\n       ; get all values of :db.cardinality/many attribute\n       (->> (datoms db :eavt eid attr) (map :v))\n  \n       ; lookup entity ids by attribute value\n       (->> (datoms db :avet attr value) (map :e))\n  \n       ; find all entities with a specific attribute\n       (->> (datoms db :aevt attr) (map :e))\n  \n       ; find “singleton” entity by its attr\n       (->> (datoms db :aevt attr) first :e)\n  \n       ; find N entities with lowest attr value (e.g. 10 earliest posts)\n       (->> (datoms db :avet attr) (take N))\n  \n       ; find N entities with highest attr value (e.g. 10 latest posts)\n       (->> (datoms db :avet attr) (reverse) (take N))\n\n   Gotchas:\n   \n   - Index lookup is usually more efficient than doing a query with a single clause.\n   - Resulting iterator is calculated in constant time and small constant memory overhead.\n   - Iterator supports efficient `first`, `next`, `reverse`, `seq` and is itself a sequence.\n   - Will not return datoms that are not part of the index (e.g. attributes with no `:db/index` in schema when querying `:avet` index).\n     - `:eavt` and `:aevt` contain all datoms.\n     - `:avet` only contains datoms for references, `:db/unique` and `:db/index` attributes.","^7D",["^ ","^7E",false,"^7F",6,"^7G",6,"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^7I",["^1A",[null,null,null,null,null]]]],"^J","^4A","^6","datascript/core.cljc","^:",13,"^7D",["^ ","^7E",false,"^7F",6,"^7G",6,"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^7I",["^1A",[null,null,null,null,null]]],"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^7J",null,"^7F",6,"^7I",["^1A",[null,null,null,null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^7Y","Index lookup. Returns a sequence of datoms (lazy iterator over actual DB index) which components (e, a, v) match passed arguments.\n\n   Datoms are sorted in index sort order. Possible `index` values are: `:eavt`, `:aevt`, `:avet`.\n\n   Usage:\n\n       ; find all datoms for entity id == 1 (any attrs and values)\n       ; sort by attribute, then value\n       (datoms db :eavt 1)\n       ; => (#datascript/Datom [1 :friends 2]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [1 :name \"Ivan\"])\n  \n       ; find all datoms for entity id == 1 and attribute == :likes (any values)\n       ; sorted by value\n       (datoms db :eavt 1 :likes)\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"])\n       \n       ; find all datoms for entity id == 1, attribute == :likes and value == \"pizza\"\n       (datoms db :eavt 1 :likes \"pizza\")\n       ; => (#datascript/Datom [1 :likes \"pizza\"])\n  \n       ; find all datoms for attribute == :likes (any entity ids and values)\n       ; sorted by entity id, then value\n       (datoms db :aevt :likes)\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; find all datoms that have attribute == `:likes` and value == `\"pizza\"` (any entity id)\n       ; `:likes` must be a unique attr, reference or marked as `:db/index true`\n       (datoms db :avet :likes \"pizza\")\n       ; => (#datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; find all datoms sorted by entity id, then attribute, then value\n       (datoms db :eavt) ; => (...)\n\n   Useful patterns:\n\n       ; get all values of :db.cardinality/many attribute\n       (->> (datoms db :eavt eid attr) (map :v))\n  \n       ; lookup entity ids by attribute value\n       (->> (datoms db :avet attr value) (map :e))\n  \n       ; find all entities with a specific attribute\n       (->> (datoms db :aevt attr) (map :e))\n  \n       ; find “singleton” entity by its attr\n       (->> (datoms db :aevt attr) first :e)\n  \n       ; find N entities with lowest attr value (e.g. 10 earliest posts)\n       (->> (datoms db :avet attr) (take N))\n  \n       ; find N entities with highest attr value (e.g. 10 latest posts)\n       (->> (datoms db :avet attr) (reverse) (take N))\n\n   Gotchas:\n   \n   - Index lookup is usually more efficient than doing a query with a single clause.\n   - Resulting iterator is calculated in constant time and small constant memory overhead.\n   - Iterator supports efficient `first`, `next`, `reverse`, `seq` and is itself a sequence.\n   - Will not return datoms that are not part of the index (e.g. attributes with no `:db/index` in schema when querying `:avet` index).\n     - `:eavt` and `:aevt` contain all datoms.\n     - `:avet` only contains datoms for references, `:db/unique` and `:db/index` attributes.",["^1A",[["^W","^8S"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["~$db/-datoms","^W","^8S",null,null,null,null]]]],["^1A",[["^W","^8S","^8T"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^8X","^W","^8S","^8T",null,null,null]]]],["^1A",[["^W","^8S","^8T","^8U"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^8X","^W","^8S","^8T","^8U",null,null]]]],["^1A",[["^W","^8S","^8T","^8U","^8V"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^8X","^W","^8S","^8T","^8U","^8V",null]]]],["^1A",[["^W","^8S","^8T","^8U","^8V","^8W"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^8X","^W","^8S","^8T","^8U","^8V","^8W"]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U","^7V"],["^ ","^7F",3,"^7E",false,"^7U","^7V"],["^ ","^7F",4,"^7E",false,"^7U","^7V"],["^ ","^7F",5,"^7E",false,"^7U","^7V"],["^ ","^7F",6,"^7E",false,"^7U","^7V"]],"^7",295,"^9",295,"^7G",6,"^7W",true,"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^78","Index lookup. Returns a sequence of datoms (lazy iterator over actual DB index) which components (e, a, v) match passed arguments.\n\n   Datoms are sorted in index sort order. Possible `index` values are: `:eavt`, `:aevt`, `:avet`.\n\n   Usage:\n\n       ; find all datoms for entity id == 1 (any attrs and values)\n       ; sort by attribute, then value\n       (datoms db :eavt 1)\n       ; => (#datascript/Datom [1 :friends 2]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [1 :name \"Ivan\"])\n  \n       ; find all datoms for entity id == 1 and attribute == :likes (any values)\n       ; sorted by value\n       (datoms db :eavt 1 :likes)\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"])\n       \n       ; find all datoms for entity id == 1, attribute == :likes and value == \"pizza\"\n       (datoms db :eavt 1 :likes \"pizza\")\n       ; => (#datascript/Datom [1 :likes \"pizza\"])\n  \n       ; find all datoms for attribute == :likes (any entity ids and values)\n       ; sorted by entity id, then value\n       (datoms db :aevt :likes)\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; find all datoms that have attribute == `:likes` and value == `\"pizza\"` (any entity id)\n       ; `:likes` must be a unique attr, reference or marked as `:db/index true`\n       (datoms db :avet :likes \"pizza\")\n       ; => (#datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; find all datoms sorted by entity id, then attribute, then value\n       (datoms db :eavt) ; => (...)\n\n   Useful patterns:\n\n       ; get all values of :db.cardinality/many attribute\n       (->> (datoms db :eavt eid attr) (map :v))\n  \n       ; lookup entity ids by attribute value\n       (->> (datoms db :avet attr value) (map :e))\n  \n       ; find all entities with a specific attribute\n       (->> (datoms db :aevt attr) (map :e))\n  \n       ; find “singleton” entity by its attr\n       (->> (datoms db :aevt attr) first :e)\n  \n       ; find N entities with lowest attr value (e.g. 10 earliest posts)\n       (->> (datoms db :avet attr) (take N))\n  \n       ; find N entities with highest attr value (e.g. 10 latest posts)\n       (->> (datoms db :avet attr) (reverse) (take N))\n\n   Gotchas:\n   \n   - Index lookup is usually more efficient than doing a query with a single clause.\n   - Resulting iterator is calculated in constant time and small constant memory overhead.\n   - Iterator supports efficient `first`, `next`, `reverse`, `seq` and is itself a sequence.\n   - Will not return datoms that are not part of the index (e.g. attributes with no `:db/index` in schema when querying `:avet` index).\n     - `:eavt` and `:aevt` contain all datoms.\n     - `:avet` only contains datoms for references, `:db/unique` and `:db/index` attributes."],"^81",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^:",18,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]],"^74",["^1A",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]]],"^7I",["^1A",[null,null,null]]],"^8",11,"^7",200,"^9",200,"^7U","^1=","^74",["^1A",["^75",["^1A",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]]]]],"^78","Low-level fn for creating database quickly from a trusted sequence of datoms.\n   Does no validation on inputs, so `datoms` must be well-formed and match schema.\n   Used internally in db (de)serialization. See also [[datom]].\n   For options, see [[empty-db]]"],"^J","^33","^6","datascript/core.cljc","^:",18,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]],"^74",["^1A",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]]],"^7I",["^1A",[null,null,null]]],"^7H",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]],"^7J",null,"^7F",3,"^7I",["^1A",[null,null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^81","Low-level fn for creating database quickly from a trusted sequence of datoms.\n   Does no validation on inputs, so `datoms` must be well-formed and match schema.\n   Used internally in db (de)serialization. See also [[datom]].\n   For options, see [[empty-db]]",["^1A",[["^7Y"],["^1A",["~$db/init-db","^7Y",null,["^ "]]]]],["^1A",[["^7Y","^7Z"],["^1A",["^8Y","^7Y","^7Z",["^ "]]]]],["^1A",[["^7Y","^7Z","^7["],["^1A",["^8Y","^7Y","^7Z",["^1A",["~$maybe-adapt-storage","^7["]]]]]]]]],"^7E",false,"^7T",[["^ ","^7F",1,"^7E",false,"^7U","^1="],["^ ","^7F",2,"^7E",false,"^7U","^1="],["^ ","^7F",3,"^7E",false,"^7U","^1="]],"^7",200,"^8F","^1=","^9",200,"^7G",3,"^7U","^1=","^7W",true,"^74",["^1A",[["^7Y"],["^7Y","^7Z"],["^7Y","^7Z","^7["]]],"^78","Low-level fn for creating database quickly from a trusted sequence of datoms.\n   Does no validation on inputs, so `datoms` must be well-formed and match schema.\n   Used internally in db (de)serialization. See also [[datom]].\n   For options, see [[empty-db]]"],"~$rseek-datoms",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",417,"^8",7,"^9",417,"^:",19,"^74",["^1A",["^75",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]]]],"^78","Same as [[seek-datoms]], but goes backwards until the beginning of the index.","^7D",["^ ","^7E",false,"^7F",6,"^7G",6,"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^7I",["^1A",[null,null,null,null,null]]]],"^J","^4B","^6","datascript/core.cljc","^:",19,"^7D",["^ ","^7E",false,"^7F",6,"^7G",6,"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^7I",["^1A",[null,null,null,null,null]]],"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^7J",null,"^7F",6,"^7I",["^1A",[null,null,null,null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^8[","Same as [[seek-datoms]], but goes backwards until the beginning of the index.",["^1A",[["^W","^8S"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["~$db/-rseek-datoms","^W","^8S",null,null,null,null]]]],["^1A",[["^W","^8S","^8T"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^90","^W","^8S","^8T",null,null,null]]]],["^1A",[["^W","^8S","^8T","^8U"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^90","^W","^8S","^8T","^8U",null,null]]]],["^1A",[["^W","^8S","^8T","^8U","^8V"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^90","^W","^8S","^8T","^8U","^8V",null]]]],["^1A",[["^W","^8S","^8T","^8U","^8V","^8W"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^90","^W","^8S","^8T","^8U","^8V","^8W"]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U","^7V"],["^ ","^7F",3,"^7E",false,"^7U","^7V"],["^ ","^7F",4,"^7E",false,"^7U","^7V"],["^ ","^7F",5,"^7E",false,"^7U","^7V"],["^ ","^7F",6,"^7E",false,"^7U","^7V"]],"^7",417,"^9",417,"^7G",6,"^7W",true,"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^78","Same as [[seek-datoms]], but goes backwards until the beginning of the index."],"~$is-filtered",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",247,"^8",7,"^9",247,"^:",18,"^74",["^1A",["^75",["^1A",[["~$x"]]]]],"^78","Returns `true` if this database was filtered using [[filter]], `false` otherwise."],"^J","^4E","^6","datascript/core.cljc","^:",18,"^7H",["^1A",[["~$x"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^91","Returns `true` if this database was filtered using [[filter]], `false` otherwise.",["~$x"],["^1A",["^8P","^1>","~$x"]]]]],"^7E",false,"^7",247,"^8F","^8R","^9",247,"^7G",1,"^7W",true,"^74",["^1A",["^75",["^1A",[["~$x"]]]]],"^78","Returns `true` if this database was filtered using [[filter]], `false` otherwise."],"~$q",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",144,"^8",3,"^9",144,"^:",4,"^74",["^1A",["^75",["^1A",[["~$query","~$&","~$inputs"]]]]],"^78","Executes a datalog query. See [docs.datomic.com/on-prem/query.html](https://docs.datomic.com/on-prem/query.html).\n\n          Usage:\n          \n          ```\n          (q '[:find ?value\n               :where [_ :likes ?value]]\n             db)\n          ; => #{[\"fries\"] [\"candy\"] [\"pie\"] [\"pizza\"]}\n          ```"],"^J","^3<","^6","datascript/core.cljc","^:",4,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","~$q","~$dq/q"]]],"^7",132,"^9",144,"^74",["^1A",["^75",["^1A",[["^92","~$&","^93"]]]]],"^78","Executes a datalog query. See [docs.datomic.com/on-prem/query.html](https://docs.datomic.com/on-prem/query.html).\n\n          Usage:\n          \n          ```\n          (q '[:find ?value\n               :where [_ :likes ?value]]\n             db)\n          ; => #{[\"fries\"] [\"candy\"] [\"pie\"] [\"pizza\"]}\n          ```"],"^7Z",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",242,"^8",3,"^9",242,"^:",9,"^74",["^1A",["^75",["^1A",[["^W"]]]]],"^78","Returns a schema of a database."],"^J","^1W","^6","datascript/core.cljc","^:",9,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^7Z","~$db/-schema"]]],"^7",240,"^9",242,"^74",["^1A",["^75",["^1A",[["^W"]]]]],"^78","Returns a schema of a database."],"~$index-range",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",425,"^8",7,"^9",425,"^:",18,"^74",["^1A",["^75",["^1A",[["^W","~$attr","~$start","~$end"]]]]],"^78","Returns part of `:avet` index between `[_ attr start]` and `[_ attr end]` in AVET sort order.\n  \n   Same properties as [[datoms]].\n   \n   `attr` must be a reference, unique attribute or marked as `:db/index true`.\n   \n   Usage:\n\n       (index-range db :likes \"a\" \"zzzzzzzzz\")\n       ; => (#datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n        \n       (index-range db :likes \"egg\" \"pineapple\")\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [2 :likes \"pie\"])\n           \n   Useful patterns:\n     \n       ; find all entities with age in a specific range (inclusive)\n       (->> (index-range db :age 18 60) (map :e))"],"^J","^1Y","^6","datascript/core.cljc","^:",18,"^7H",["^1A",[["^W","^97","^98","^99"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^96","Returns part of `:avet` index between `[_ attr start]` and `[_ attr end]` in AVET sort order.\n  \n   Same properties as [[datoms]].\n   \n   `attr` must be a reference, unique attribute or marked as `:db/index true`.\n   \n   Usage:\n\n       (index-range db :likes \"a\" \"zzzzzzzzz\")\n       ; => (#datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n        \n       (index-range db :likes \"egg\" \"pineapple\")\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [2 :likes \"pie\"])\n           \n   Useful patterns:\n     \n       ; find all entities with age in a specific range (inclusive)\n       (->> (index-range db :age 18 60) (map :e))",["^W","^97","^98","^99"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["~$db/-index-range","^W","^97","^98","^99"]]]]],"^7E",false,"^7",425,"^8F","^7V","^9",425,"^7G",4,"^7W",true,"^74",["^1A",["^75",["^1A",[["^W","^97","^98","^99"]]]]],"^78","Returns part of `:avet` index between `[_ attr start]` and `[_ attr end]` in AVET sort order.\n  \n   Same properties as [[datoms]].\n   \n   `attr` must be a reference, unique attribute or marked as `:db/index true`.\n   \n   Usage:\n\n       (index-range db :likes \"a\" \"zzzzzzzzz\")\n       ; => (#datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n        \n       (index-range db :likes \"egg\" \"pineapple\")\n       ; => (#datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [2 :likes \"pie\"])\n           \n   Useful patterns:\n     \n       ; find all entities with age in a specific range (inclusive)\n       (->> (index-range db :age 18 60) (map :e))"],"~$pull-many",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",128,"^8",3,"^9",128,"^:",12,"^74",["^1A",["^75",["^1A",[["^W","^76","~$eids"]]]]],"^78","Same as [[pull]], but accepts sequence of ids and returns sequence of maps.\n\n             Usage:\n\n             ```\n             (pull-many db [:db/id :name] [1 2])\n             ; => [{:db/id 1, :name \"Ivan\"}\n             ;     {:db/id 2, :name \"Oleg\"}]\n             ```"],"^J","^3@","^6","datascript/core.cljc","^:",12,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9;","~$dp/pull-many"]]],"^7",118,"^9",128,"^74",["^1A",["^75",["^1A",[["^W","^76","^9<"]]]]],"^78","Same as [[pull]], but accepts sequence of ids and returns sequence of maps.\n\n             Usage:\n\n             ```\n             (pull-many db [:db/id :name] [1 2])\n             ; => [{:db/id 1, :name \"Ivan\"}\n             ;     {:db/id 2, :name \"Oleg\"}]\n             ```"],"^8Z",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",149,"^8",8,"^9",149,"^:",27,"^83",true,"^74",["^1A",["^75",["^1A",[["^7["]]]]]],"^83",true,"^J","^3=","^6","datascript/core.cljc","^:",27,"^7H",["^1A",[["^7["]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^84","^8Z",["^7["],"^7["]]],"^7E",false,"^7",149,"^9",149,"^7G",1,"^7W",true,"^74",["^1A",["^75",["^1A",[["^7["]]]]]],"~$squuid",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",795,"^8",32,"^9",795,"^:",38,"^74",["^1A",["^75",["^1A",[[],["~$msec"]]]]]],"^J","^21","^6","datascript/core.cljc","^:",38,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9>","Generates a UUID that grow with time. Such UUIDs will always go to the end  of the index and that will minimize insertions in the middle.\n  \n   Consist of 64 bits of current UNIX timestamp (in seconds) and 64 random bits (2^64 different unique values per second).","~$util/squuid"]]],"^7",795,"^9",795,"^74",["^1A",["^75",["^1A",[[],["^9?"]]]]],"^78","Generates a UUID that grow with time. Such UUIDs will always go to the end  of the index and that will minimize insertions in the middle.\n  \n   Consist of 64 bits of current UNIX timestamp (in seconds) and 64 random bits (2^64 different unique values per second)."],"~$from-serializable",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",235,"^8",3,"^9",235,"^:",20,"^7U","^1=","^74",["^1A",["^75",["^1A",[["~$serializable"],["^9B","^7["]]]]],"^78","Creates db from a data structure (not string!) produced by serializable.\n\n             Opts:\n\n             `:thaw-fn` Non-primitive values will be deserialized using this.\n             Must match :freeze-fn from serializable. Optional. `clojure.edn/read-string`\n             by default."],"^J","^20","^6","datascript/core.cljc","^:",20,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9A","~$ds/from-serializable"]]],"^7",226,"^9",235,"^7U","^1=","^74",["^1A",["^75",["^1A",[["^9B"],["^9B","^7["]]]]],"^78","Creates db from a data structure (not string!) produced by serializable.\n\n             Opts:\n\n             `:thaw-fn` Non-primitive values will be deserialized using this.\n             Must match :freeze-fn from serializable. Optional. `clojure.edn/read-string`\n             by default."],"~$db?",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",185,"^8",3,"^9",185,"^:",6,"^74",["^1A",["^75",["^1A",[["~$x"]]]]],"^78","Returns `true` if the given value is an immutable database, `false` otherwise."],"^J","^27","^6","datascript/core.cljc","^:",6,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9D","^8J"]]],"^7",183,"^9",185,"^74",["^1A",["^75",["^1A",[["~$x"]]]]],"^78","Returns `true` if the given value is an immutable database, `false` otherwise."],"~$create-conn",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",486,"^8",7,"^9",486,"^:",18,"^74",["^1A",["^75",["^1A",[[],["^7Z"],["^7Z","^7["]]]]],"^78","Creates a mutable reference (a “connection”) to an empty immutable database.\n\n   Connections are lightweight in-memory structures (~atoms) with direct support of transaction listeners ([[listen!]], [[unlisten!]]) and other handy DataScript APIs ([[transact!]], [[reset-conn!]], [[db]]).\n\n   To access underlying immutable DB value, deref: `@conn`.\n   \n   For list of options, see [[empty-db]].\n   \n   If you specify `:storage` option, conn will be stored automatically after each transaction","^7D",["^ ","^7E",false,"^7F",2,"^7G",2,"^7H",[[],["^7Z"],["^7Z","^7["]],"^74",["^1A",[[],["^7Z"],["^7Z","^7["]]],"^7I",["^1A",[null,null,null]]]],"^J","^2>","^6","datascript/core.cljc","^:",18,"^7D",["^ ","^7E",false,"^7F",2,"^7G",2,"^7H",[[],["^7Z"],["^7Z","^7["]],"^74",["^1A",[[],["^7Z"],["^7Z","^7["]]],"^7I",["^1A",[null,null,null]]],"^7H",[[],["^7Z"],["^7Z","^7["]],"^7J",null,"^7F",2,"^7I",["^1A",[null,null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^9E","Creates a mutable reference (a “connection”) to an empty immutable database.\n\n   Connections are lightweight in-memory structures (~atoms) with direct support of transaction listeners ([[listen!]], [[unlisten!]]) and other handy DataScript APIs ([[transact!]], [[reset-conn!]], [[db]]).\n\n   To access underlying immutable DB value, deref: `@conn`.\n   \n   For list of options, see [[empty-db]].\n   \n   If you specify `:storage` option, conn will be stored automatically after each transaction",["^1A",[[],["^1A",["^80",["^1A",["~$empty-db"]]]]]],["^1A",[["^7Z"],["^1A",["^80",["^1A",["^9F","^7Z"]]]]]],["^1A",[["^7Z","^7["],["^1A",["^80",["^1A",["^9F","^7Z","^7["]]]]]]]]],"^7E",false,"^7T",[["^ ","^7F",0,"^7E",false,"^7U","^44"],["^ ","^7F",1,"^7E",false,"^7U","^44"],["^ ","^7F",2,"^7E",false,"^7U","^44"]],"^7",486,"^9",486,"^7G",2,"^7W",true,"^74",["^1A",[[],["^7Z"],["^7Z","^7["]]],"^78","Creates a mutable reference (a “connection”) to an empty immutable database.\n\n   Connections are lightweight in-memory structures (~atoms) with direct support of transaction listeners ([[listen!]], [[unlisten!]]) and other handy DataScript APIs ([[transact!]], [[reset-conn!]], [[db]]).\n\n   To access underlying immutable DB value, deref: `@conn`.\n   \n   For list of options, see [[empty-db]].\n   \n   If you specify `:storage` option, conn will be stored automatically after each transaction"],"~$squuid-time-millis",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",801,"^8",29,"^9",801,"^:",47,"^74",["^1A",["^75",["^1A",[["~$uuid"]]]]]],"^J","^3T","^6","datascript/core.cljc","^:",47,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9G","Returns time that was used in [[squuid]] call, in milliseconds, rounded to the closest second.","~$util/squuid-time-millis"]]],"^7",801,"^9",801,"^74",["^1A",["^75",["^1A",[["^9H"]]]]],"^78","Returns time that was used in [[squuid]] call, in milliseconds, rounded to the closest second."],"~$datom",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",194,"^8",3,"^9",194,"^:",8,"^7U","^1<","^74",["^1A",["^75",["^1A",[["~$e","~$a","~$v"],["~$e","~$a","~$v","~$tx"],["~$e","~$a","~$v","^9K","~$added"]]]]],"^78","Low-level fn to create raw datoms.\n\n             Optionally with transaction id (number) and `added` flag (`true` for addition, `false` for retraction).\n\n             See also [[init-db]]."],"^J","^3R","^6","datascript/core.cljc","^:",8,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9J","~$db/datom"]]],"^7",187,"^9",194,"^7U","^1<","^74",["^1A",["^75",["^1A",[["~$e","~$a","~$v"],["~$e","~$a","~$v","^9K"],["~$e","~$a","~$v","^9K","^9L"]]]]],"^78","Low-level fn to create raw datoms.\n\n             Optionally with transaction id (number) and `added` flag (`true` for addition, `false` for retraction).\n\n             See also [[init-db]]."],"~$entity-db",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",83,"^8",11,"^9",83,"^:",20,"^7U","^1=","^74",["^1A",["^75",["^1A",[["^8G"]]]]],"^78","Returns a db that entity was created from."],"^J","^2;","^6","datascript/core.cljc","^:",20,"^7H",["^1A",[["^8G"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^9N","Returns a db that entity was created from.",["^8G"],["^ ","^7M",[["^1A",["~$de/entity?","^8G"]]]],["^1A",["~$.-db","^8G"]]]]],"^7E",false,"^7",83,"^8F","^1=","^9",83,"^7G",1,"^7U","^1=","^7W",true,"^74",["^1A",["^75",["^1A",[["^8G"]]]]],"^78","Returns a db that entity was created from."],"^W",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",735,"^8",11,"^9",735,"^:",13,"^7U","^1=","^74",["^1A",["^75",["^1A",[["^7A"]]]]],"^78","Returns the underlying immutable database value from a connection.\n   \n   Exists for Datomic API compatibility. Prefer using `@conn` directly if possible."],"^J","^3X","^6","datascript/core.cljc","^:",13,"^7H",["^1A",[["^7A"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^W","Returns the underlying immutable database value from a connection.\n   \n   Exists for Datomic API compatibility. Prefer using `@conn` directly if possible.",["^7A"],["^ ","^7M",[["^1A",["^7N","^7A"]]]],["^1A",["^8?","^7A"]]]]],"^7E",false,"^7",735,"^8F","^1=","^9",735,"^7G",1,"^7U","^1=","^7W",true,"^74",["^1A",["^75",["^1A",[["^7A"]]]]],"^78","Returns the underlying immutable database value from a connection.\n   \n   Exists for Datomic API compatibility. Prefer using `@conn` directly if possible."],"~$transact-async",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",783,"^8",7,"^9",783,"^:",21,"^74",["^1A",["^75",["^1A",[["^7A","~$tx-data"],["^7A","^9R","~$tx-meta"]]]]],"^78","In CLJ, calls [[transact!]] on a future thread pool, returning immediately.\n  \n   In CLJS, just calls [[transact!]] and returns a realized future.","^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^7I",["^1A",[null,null]]]],"^J","^2B","^6","datascript/core.cljc","^:",21,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^7I",["^1A",[null,null]]],"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^7J",null,"^7F",3,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^9Q","In CLJ, calls [[transact!]] on a future thread pool, returning immediately.\n  \n   In CLJS, just calls [[transact!]] and returns a realized future.",["^1A",[["^7A","^9R"],["^1A",["^9Q","^7A","^9R",null]]]],["^1A",[["^7A","^9R","^9S"],["^ ","^7M",[["^1A",["^7N","^7A"]]]],["^1A",["^82",["^1A",["^89",[],["^1A",["~$transact!","^7A","^9R","^9S"]]]]]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U","^7V"],["^ ","^7F",3,"^7E",false,"^7U","^46"]],"^7",783,"^9",783,"^7G",3,"^7W",true,"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^78","In CLJ, calls [[transact!]] on a future thread pool, returning immediately.\n  \n   In CLJS, just calls [[transact!]] and returns a realized future."],"~$data-readers",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",704,"^8",3,"^9",704,"^:",15,"^78","Data readers for EDN readers. In CLJS they’re registered automatically. In CLJ, if `data_readers.clj` do not work, you can always do\n\n             ```\n             (clojure.edn/read-string {:readers data-readers} \"...\")\n             ```"],"^J","^3Z","^6","datascript/core.cljc","^:",15,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9U",["^4J",[["^1A",["^75","~$datascript/Datom"]],"~$db/datom-from-reader",["^1A",["^75","~$datascript/DB"]],"~$db/db-from-reader"]]]]],"^7",699,"^9",704,"^7U","~$cljs.core/IMap","^78","Data readers for EDN readers. In CLJS they’re registered automatically. In CLJ, if `data_readers.clj` do not work, you can always do\n\n             ```\n             (clojure.edn/read-string {:readers data-readers} \"...\")\n             ```"],"~$tx0",["^ ","~:no-doc",true,"^5",["^ ","^6","datascript/core.cljc","^7",20,"^8",23,"^9",20,"^:",26,"^:0",true,"~:const",true],"^J","^2F","^6","datascript/core.cljc","^:",26,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9[","~$db/tx0"]]],"^:1",true,"^7",20,"^9",20,"^7U","~$number"],"~$find-datom",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^:",24,"^7D",["^ ","^7E",false,"^7F",6,"^7G",6,"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^7I",["^1A",[null,null,null,null,null]]],"^8",14,"^7",372,"^9",372,"^7U","^1<","^74",["^1A",["^75",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]]]],"^78","Same as [[datoms]], but only returns single datom. Faster than `(first (datoms ...))`"],"^J","^2J","^6","datascript/core.cljc","^:",24,"^7D",["^ ","^7E",false,"^7F",6,"^7G",6,"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^7I",["^1A",[null,null,null,null,null]]],"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^7J",null,"^7F",6,"^7I",["^1A",[null,null,null,null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^:4","Same as [[datoms]], but only returns single datom. Faster than `(first (datoms ...))`",["^1A",[["^W","^8S"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["~$db/find-datom","^W","^8S",null,null,null,null]]]],["^1A",[["^W","^8S","^8T"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^:5","^W","^8S","^8T",null,null,null]]]],["^1A",[["^W","^8S","^8T","^8U"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^:5","^W","^8S","^8T","^8U",null,null]]]],["^1A",[["^W","^8S","^8T","^8U","^8V"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^:5","^W","^8S","^8T","^8U","^8V",null]]]],["^1A",[["^W","^8S","^8T","^8U","^8V","^8W"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^:5","^W","^8S","^8T","^8U","^8V","^8W"]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U",["^H",["^7V","~$clj-nil"]]],["^ ","^7F",3,"^7E",false,"^7U",["^H",["^7V","^:6"]]],["^ ","^7F",4,"^7E",false,"^7U",["^H",["^7V","^:6"]]],["^ ","^7F",5,"^7E",false,"^7U",["^H",["^7V","^:6"]]],["^ ","^7F",6,"^7E",false,"^7U",["^H",["^7V","^:6"]]]],"^7",372,"^8F","^1<","^9",372,"^7G",6,"^7U","^1<","^7W",true,"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^78","Same as [[datoms]], but only returns single datom. Faster than `(first (datoms ...))`"],"~$t_datascript$core23866",["^ ","~:num-fields",4,"~:protocols",["^H",["~$cljs.core/IDerefWithTimeout","~$cljs.core/IPending","~$cljs.core/IMeta","^42","~$cljs.core/IWithMeta"]],"^J","^46","^6","datascript/core.cljc","~:type",true,"~:anonymous",true,"^8",null,"^79",["^ ","^7:","^7;","^7<",["^1A",["~$cljs.core/deftype","^:7",["~$f","^86","^88","~$meta23867"],"^:=",["^1A",["~$-with-meta",["~$_23868","^:A"],["^1A",["~$new","^:7","~$f","^86","^88","^:A"]]]],"^:<",["^1A",["~$-meta",["^:C"],"^:A"]],"^8=",["^1A",["^8>",["~$_"],["^1A",["^8?","^86"]]]],"^8@",["^1A",["^8A",["~$_","~$_","^8B"],["^1A",["^8C",["^1A",["^8?","^88"]],["^1A",["^8?","^86"]],"^8B"]]]],"^8D",["^1A",["^8E",["~$_"],["^1A",["^8?","^88"]]]]]]],"^7",null,"~:record",false,"^7U","~$function","~:skip-protocol-flag",["^H",["^::","^:;","^:<","^42","^:="]]],"~$settings",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",856,"^8",7,"^9",856,"^:",15,"^74",["^1A",["^75",["^1A",[["^W"]]]]]],"^J","^2Q","^6","datascript/core.cljc","^:",15,"^7H",["^1A",[["^W"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^:I",["^W"],["^1A",["~$set/settings",["^1A",["~:eavt","^W"]]]]]]],"^7E",false,"^7",856,"^8F","^9Z","^9",856,"^7G",1,"^7W",true,"^74",["^1A",["^75",["^1A",[["^W"]]]]]],"~$t_datascript$core23848",["^ ","^:8",5,"^:9",["^H",["^::","^:;","^:<","^42","^:="]],"^J","^2P","^6","datascript/core.cljc","^:>",true,"^:?",true,"^8",null,"^79",["^ ","^7:","^7;","^7<",["^1A",["^:@","^:L",["^7A","^9R","^9S","^86","~$meta23849"],"^:=",["^1A",["^:B",["~$_23850","^:M"],["^1A",["^:D","^:L","^7A","^9R","^9S","^86","^:M"]]]],"^:<",["^1A",["^:E",["^:N"],"^:M"]],"^8=",["^1A",["^8>",["~$_"],"^86"]],"^8@",["^1A",["^8A",["~$_","~$_","~$_"],"^86"]],"^8D",["^1A",["^8E",["~$_"],true]]]]],"^7",null,"^:F",false,"^7U","^:G","^:H",["^H",["^::","^:;","^:<","^42","^:="]]],"~$resolve-tempid",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",728,"^8",7,"^9",728,"^:",21,"^74",["^1A",["^75",["^1A",[["~$_db","~$tempids","~$tempid"]]]]],"^78","Does a lookup in tempids map, returning an entity id that tempid was resolved to.\n   \n   Exists for Datomic API compatibility. Prefer using map lookup directly if possible."],"^J","^4=","^6","datascript/core.cljc","^:",21,"^7H",["^1A",[["^:P","^:Q","^:R"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^:O","Does a lookup in tempids map, returning an entity id that tempid was resolved to.\n   \n   Exists for Datomic API compatibility. Prefer using map lookup directly if possible.",["^:P","^:Q","^:R"],["^1A",["~$get","^:Q","^:R"]]]]],"^7E",false,"^7",728,"^8F",["^H",["^7V","^:6"]],"^9",728,"^7G",3,"^7W",true,"^74",["^1A",["^75",["^1A",[["^:P","^:Q","^:R"]]]]],"^78","Does a lookup in tempids map, returning an entity id that tempid was resolved to.\n   \n   Exists for Datomic API compatibility. Prefer using map lookup directly if possible."],"^9F",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^:",19,"^7D",["^ ","^7E",false,"^7F",2,"^7G",2,"^7H",[[],["^7Z"],["^7Z","^7["]],"^74",["^1A",[[],["^7Z"],["^7Z","^7["]]],"^7I",["^1A",[null,null,null]]],"^8",11,"^7",156,"^9",156,"^7U","^1=","^74",["^1A",["^75",["^1A",[[],["^7Z"],["^7Z","^7["]]]]],"^78","Creates an empty database with an optional schema.\n\n   Usage:\n   \n   ```\n   (empty-db) ; => #datascript/DB {:schema {}, :datoms []}\n\n   (empty-db {:likes {:db/cardinality :db.cardinality/many}})\n   ; => #datascript/DB {:schema {:likes {:db/cardinality :db.cardinality/many}}\n   ;                    :datoms []}\n   ```\n   \n   Options are:\n   \n   :branching-factor <int>, default 512. B-tree max node length\n   :ref-type         :strong | :soft | :weak, default :soft. How will nodes that are already\n                     stored on disk be referenced. Soft or weak means they might be unloaded\n                     from memory under memory pressure and later fetched from storage again.\n   :storage          <IStorage>. Will be used to store this db later with `(d/store db)`"],"^J","^4:","^6","datascript/core.cljc","^:",19,"^7D",["^ ","^7E",false,"^7F",2,"^7G",2,"^7H",[[],["^7Z"],["^7Z","^7["]],"^74",["^1A",[[],["^7Z"],["^7Z","^7["]]],"^7I",["^1A",[null,null,null]]],"^7H",[[],["^7Z"],["^7Z","^7["]],"^7J",null,"^7F",2,"^7I",["^1A",[null,null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^9F","Creates an empty database with an optional schema.\n\n   Usage:\n   \n   ```\n   (empty-db) ; => #datascript/DB {:schema {}, :datoms []}\n\n   (empty-db {:likes {:db/cardinality :db.cardinality/many}})\n   ; => #datascript/DB {:schema {:likes {:db/cardinality :db.cardinality/many}}\n   ;                    :datoms []}\n   ```\n   \n   Options are:\n   \n   :branching-factor <int>, default 512. B-tree max node length\n   :ref-type         :strong | :soft | :weak, default :soft. How will nodes that are already\n                     stored on disk be referenced. Soft or weak means they might be unloaded\n                     from memory under memory pressure and later fetched from storage again.\n   :storage          <IStorage>. Will be used to store this db later with `(d/store db)`",["^1A",[[],["^1A",["~$db/empty-db",null,["^ "]]]]],["^1A",[["^7Z"],["^1A",["^:T","^7Z",["^ "]]]]],["^1A",[["^7Z","^7["],["^1A",["^:T","^7Z",["^1A",["^8Z","^7["]]]]]]]]],"^7E",false,"^7T",[["^ ","^7F",0,"^7E",false,"^7U","^1="],["^ ","^7F",1,"^7E",false,"^7U","^1="],["^ ","^7F",2,"^7E",false,"^7U","^1="]],"^7",156,"^8F","^1=","^9",156,"^7G",2,"^7U","^1=","^7W",true,"^74",["^1A",[[],["^7Z"],["^7Z","^7["]]],"^78","Creates an empty database with an optional schema.\n\n   Usage:\n   \n   ```\n   (empty-db) ; => #datascript/DB {:schema {}, :datoms []}\n\n   (empty-db {:likes {:db/cardinality :db.cardinality/many}})\n   ; => #datascript/DB {:schema {:likes {:db/cardinality :db.cardinality/many}}\n   ;                    :datoms []}\n   ```\n   \n   Options are:\n   \n   :branching-factor <int>, default 512. B-tree max node length\n   :ref-type         :strong | :soft | :weak, default :soft. How will nodes that are already\n                     stored on disk be referenced. Soft or weak means they might be unloaded\n                     from memory under memory pressure and later fetched from storage again.\n   :storage          <IStorage>. Will be used to store this db later with `(d/store db)`"],"~$datom?",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",198,"^8",3,"^9",198,"^:",9,"^74",["^1A",["^75",["^1A",[["~$x"]]]]],"^78","Returns `true` if the given value is a datom, `false` otherwise."],"^J","^2[","^6","datascript/core.cljc","^:",9,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^:U","~$db/datom?"]]],"^7",196,"^9",198,"^74",["^1A",["^75",["^1A",[["~$x"]]]]],"^78","Returns `true` if the given value is a datom, `false` otherwise."],"^9T",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",541,"^8",7,"^9",541,"^:",16,"^74",["^1A",["^75",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]]]],"^78","Applies transaction the underlying database value and atomically updates connection reference to point to the result of that transaction, new db value.\n  \n   Returns transaction report, a map:\n\n       { :db-before ...       ; db value before transaction\n         :db-after  ...       ; db value after transaction\n         :tx-data   [...]     ; plain datoms that were added/retracted from db-before\n         :tempids   {...}     ; map of tempid from tx-data => assigned entid in db-after\n         :tx-meta   tx-meta } ; the exact value you passed as `tx-meta`\n\n  Note! `conn` will be updated in-place and is not returned from [[transact!]].\n  \n  Usage:\n\n      ; add a single datom to an existing entity (1)\n      (transact! conn [[:db/add 1 :name \"Ivan\"]])\n  \n      ; retract a single datom\n      (transact! conn [[:db/retract 1 :name \"Ivan\"]])\n  \n      ; retract single entity attribute\n      (transact! conn [[:db.fn/retractAttribute 1 :name]])\n  \n      ; ... or equivalently (since Datomic changed its API to support this):\n      (transact! conn [[:db/retract 1 :name]])\n      \n      ; retract all entity attributes (effectively deletes entity)\n      (transact! conn [[:db.fn/retractEntity 1]])\n  \n      ; create a new entity (`-1`, as any other negative value, is a tempid\n      ; that will be replaced with DataScript to a next unused eid)\n      (transact! conn [[:db/add -1 :name \"Ivan\"]])\n  \n      ; check assigned id (here `*1` is a result returned from previous `transact!` call)\n      (def report *1)\n      (:tempids report) ; => {-1 296}\n  \n      ; check actual datoms inserted\n      (:tx-data report) ; => [#datascript/Datom [296 :name \"Ivan\"]]\n  \n      ; tempid can also be a string\n      (transact! conn [[:db/add \"ivan\" :name \"Ivan\"]])\n      (:tempids *1) ; => {\"ivan\" 297}\n  \n      ; reference another entity (must exist)\n      (transact! conn [[:db/add -1 :friend 296]])\n  \n      ; create an entity and set multiple attributes (in a single transaction\n      ; equal tempids will be replaced with the same yet unused entid)\n      (transact! conn [[:db/add -1 :name \"Ivan\"]\n                       [:db/add -1 :likes \"fries\"]\n                       [:db/add -1 :likes \"pizza\"]\n                       [:db/add -1 :friend 296]])\n  \n      ; create an entity and set multiple attributes (alternative map form)\n      (transact! conn [{:db/id  -1\n                        :name   \"Ivan\"\n                        :likes  [\"fries\" \"pizza\"]\n                        :friend 296}])\n      \n      ; update an entity (alternative map form). Can’t retract attributes in\n      ; map form. For cardinality many attrs, value (fish in this example)\n      ; will be added to the list of existing values\n      (transact! conn [{:db/id  296\n                        :name   \"Oleg\"\n                        :likes  [\"fish\"]}])\n\n      ; ref attributes can be specified as nested map, that will create nested entity as well\n      (transact! conn [{:db/id  -1\n                        :name   \"Oleg\"\n                        :friend {:db/id -2\n                                 :name \"Sergey\"}}])\n                                 \n      ; reverse attribute name can be used if you want created entity to become\n      ; a value in another entity reference\n      (transact! conn [{:db/id  -1\n                        :name   \"Oleg\"\n                        :_friend 296}])\n      ; equivalent to\n      (transact! conn [{:db/id  -1, :name   \"Oleg\"}\n                       {:db/id 296, :friend -1}])\n      ; equivalent to\n      (transact! conn [[:db/add  -1 :name   \"Oleg\"]\n                       [:db/add 296 :friend -1]])","^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^7I",["^1A",[null,null]]]],"^J","^4@","^6","datascript/core.cljc","^:",16,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^7I",["^1A",[null,null]]],"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^7J",null,"^7F",3,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^9T","Applies transaction the underlying database value and atomically updates connection reference to point to the result of that transaction, new db value.\n  \n   Returns transaction report, a map:\n\n       { :db-before ...       ; db value before transaction\n         :db-after  ...       ; db value after transaction\n         :tx-data   [...]     ; plain datoms that were added/retracted from db-before\n         :tempids   {...}     ; map of tempid from tx-data => assigned entid in db-after\n         :tx-meta   tx-meta } ; the exact value you passed as `tx-meta`\n\n  Note! `conn` will be updated in-place and is not returned from [[transact!]].\n  \n  Usage:\n\n      ; add a single datom to an existing entity (1)\n      (transact! conn [[:db/add 1 :name \"Ivan\"]])\n  \n      ; retract a single datom\n      (transact! conn [[:db/retract 1 :name \"Ivan\"]])\n  \n      ; retract single entity attribute\n      (transact! conn [[:db.fn/retractAttribute 1 :name]])\n  \n      ; ... or equivalently (since Datomic changed its API to support this):\n      (transact! conn [[:db/retract 1 :name]])\n      \n      ; retract all entity attributes (effectively deletes entity)\n      (transact! conn [[:db.fn/retractEntity 1]])\n  \n      ; create a new entity (`-1`, as any other negative value, is a tempid\n      ; that will be replaced with DataScript to a next unused eid)\n      (transact! conn [[:db/add -1 :name \"Ivan\"]])\n  \n      ; check assigned id (here `*1` is a result returned from previous `transact!` call)\n      (def report *1)\n      (:tempids report) ; => {-1 296}\n  \n      ; check actual datoms inserted\n      (:tx-data report) ; => [#datascript/Datom [296 :name \"Ivan\"]]\n  \n      ; tempid can also be a string\n      (transact! conn [[:db/add \"ivan\" :name \"Ivan\"]])\n      (:tempids *1) ; => {\"ivan\" 297}\n  \n      ; reference another entity (must exist)\n      (transact! conn [[:db/add -1 :friend 296]])\n  \n      ; create an entity and set multiple attributes (in a single transaction\n      ; equal tempids will be replaced with the same yet unused entid)\n      (transact! conn [[:db/add -1 :name \"Ivan\"]\n                       [:db/add -1 :likes \"fries\"]\n                       [:db/add -1 :likes \"pizza\"]\n                       [:db/add -1 :friend 296]])\n  \n      ; create an entity and set multiple attributes (alternative map form)\n      (transact! conn [{:db/id  -1\n                        :name   \"Ivan\"\n                        :likes  [\"fries\" \"pizza\"]\n                        :friend 296}])\n      \n      ; update an entity (alternative map form). Can’t retract attributes in\n      ; map form. For cardinality many attrs, value (fish in this example)\n      ; will be added to the list of existing values\n      (transact! conn [{:db/id  296\n                        :name   \"Oleg\"\n                        :likes  [\"fish\"]}])\n\n      ; ref attributes can be specified as nested map, that will create nested entity as well\n      (transact! conn [{:db/id  -1\n                        :name   \"Oleg\"\n                        :friend {:db/id -2\n                                 :name \"Sergey\"}}])\n                                 \n      ; reverse attribute name can be used if you want created entity to become\n      ; a value in another entity reference\n      (transact! conn [{:db/id  -1\n                        :name   \"Oleg\"\n                        :_friend 296}])\n      ; equivalent to\n      (transact! conn [{:db/id  -1, :name   \"Oleg\"}\n                       {:db/id 296, :friend -1}])\n      ; equivalent to\n      (transact! conn [[:db/add  -1 :name   \"Oleg\"]\n                       [:db/add 296 :friend -1]])",["^1A",[["^7A","^9R"],["^1A",["^9T","^7A","^9R",null]]]],["^1A",[["^7A","^9R","^9S"],["^ ","^7M",[["^1A",["^7N","^7A"]]]],["^1A",["^85",["~$report",["^1A",["~$-transact!","^7A","^9R","^9S"]]],["^1A",["~$doseq",[["~$_","^7B"],["^1A",["~$some->",["^1A",["^7P",["^1A",["^7Q","^7A"]]]],["^1A",["~$deref"]]]]],["^1A",["^7B","^:W"]]]],"^:W"]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U","^7V"],["^ ","^7F",3,"^7E",false,"^7U","^7V"]],"^7",541,"^9",541,"^7G",3,"^7W",true,"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^78","Applies transaction the underlying database value and atomically updates connection reference to point to the result of that transaction, new db value.\n  \n   Returns transaction report, a map:\n\n       { :db-before ...       ; db value before transaction\n         :db-after  ...       ; db value after transaction\n         :tx-data   [...]     ; plain datoms that were added/retracted from db-before\n         :tempids   {...}     ; map of tempid from tx-data => assigned entid in db-after\n         :tx-meta   tx-meta } ; the exact value you passed as `tx-meta`\n\n  Note! `conn` will be updated in-place and is not returned from [[transact!]].\n  \n  Usage:\n\n      ; add a single datom to an existing entity (1)\n      (transact! conn [[:db/add 1 :name \"Ivan\"]])\n  \n      ; retract a single datom\n      (transact! conn [[:db/retract 1 :name \"Ivan\"]])\n  \n      ; retract single entity attribute\n      (transact! conn [[:db.fn/retractAttribute 1 :name]])\n  \n      ; ... or equivalently (since Datomic changed its API to support this):\n      (transact! conn [[:db/retract 1 :name]])\n      \n      ; retract all entity attributes (effectively deletes entity)\n      (transact! conn [[:db.fn/retractEntity 1]])\n  \n      ; create a new entity (`-1`, as any other negative value, is a tempid\n      ; that will be replaced with DataScript to a next unused eid)\n      (transact! conn [[:db/add -1 :name \"Ivan\"]])\n  \n      ; check assigned id (here `*1` is a result returned from previous `transact!` call)\n      (def report *1)\n      (:tempids report) ; => {-1 296}\n  \n      ; check actual datoms inserted\n      (:tx-data report) ; => [#datascript/Datom [296 :name \"Ivan\"]]\n  \n      ; tempid can also be a string\n      (transact! conn [[:db/add \"ivan\" :name \"Ivan\"]])\n      (:tempids *1) ; => {\"ivan\" 297}\n  \n      ; reference another entity (must exist)\n      (transact! conn [[:db/add -1 :friend 296]])\n  \n      ; create an entity and set multiple attributes (in a single transaction\n      ; equal tempids will be replaced with the same yet unused entid)\n      (transact! conn [[:db/add -1 :name \"Ivan\"]\n                       [:db/add -1 :likes \"fries\"]\n                       [:db/add -1 :likes \"pizza\"]\n                       [:db/add -1 :friend 296]])\n  \n      ; create an entity and set multiple attributes (alternative map form)\n      (transact! conn [{:db/id  -1\n                        :name   \"Ivan\"\n                        :likes  [\"fries\" \"pizza\"]\n                        :friend 296}])\n      \n      ; update an entity (alternative map form). Can’t retract attributes in\n      ; map form. For cardinality many attrs, value (fish in this example)\n      ; will be added to the list of existing values\n      (transact! conn [{:db/id  296\n                        :name   \"Oleg\"\n                        :likes  [\"fish\"]}])\n\n      ; ref attributes can be specified as nested map, that will create nested entity as well\n      (transact! conn [{:db/id  -1\n                        :name   \"Oleg\"\n                        :friend {:db/id -2\n                                 :name \"Sergey\"}}])\n                                 \n      ; reverse attribute name can be used if you want created entity to become\n      ; a value in another entity reference\n      (transact! conn [{:db/id  -1\n                        :name   \"Oleg\"\n                        :_friend 296}])\n      ; equivalent to\n      (transact! conn [{:db/id  -1, :name   \"Oleg\"}\n                       {:db/id 296, :friend -1}])\n      ; equivalent to\n      (transact! conn [[:db/add  -1 :name   \"Oleg\"]\n                       [:db/add 296 :friend -1]])"],"~$->t_datascript$core23866",["^ ","^7@",null,"^5",["^ ","^:?",true,"^:9",["^H",["^::","^:;","^:<","^42","^:="]],"^:H",["^H",["^::","^:;","^:<","^42","^:="]],"~:factory","~:positional","^74",["^1A",["^75",["^1A",[["~$f","^86","^88","^:A"]]]]],"^78","Positional factory function for datascript.core/t_datascript$core23866.","^6",null],"^:9",["^H",["^::","^:;","^:<","^42","^:="]],"^J","^4D","^6","datascript/core.cljc","^7H",["^1A",[["~$f","^86","^88","^:A"]]],"^7J",null,"^7I",["^1A",[null,null]],"^:?",true,"^8",null,"^79",["^ ","^7:","^7;","^7<",["^1A",["^:@","^:7",["~$f","^86","^88","^:A"],"^:=",["^1A",["^:B",["^:C","^:A"],["^1A",["^:D","^:7","~$f","^86","^88","^:A"]]]],"^:<",["^1A",["^:E",["^:C"],"^:A"]],"^8=",["^1A",["^8>",["~$_"],["^1A",["^8?","^86"]]]],"^8@",["^1A",["^8A",["~$_","~$_","^8B"],["^1A",["^8C",["^1A",["^8?","^88"]],["^1A",["^8?","^86"]],"^8B"]]]],"^8D",["^1A",["^8E",["~$_"],["^1A",["^8?","^88"]]]]]]],"^7E",false,"^;1","^;2","^7",null,"^8F","^46","^7G",4,"^7W",true,"^74",["^1A",["^75",["^1A",[["~$f","^86","^88","^:A"]]]]],"^:H",["^H",["^::","^:;","^:<","^42","^:="]],"^78","Positional factory function for datascript.core/t_datascript$core23866."],"~$reset-schema!",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",659,"^8",7,"^9",659,"^:",20,"^74",["^1A",["^75",["^1A",[["^7A","^7Z"]]]]]],"^J","^38","^6","datascript/core.cljc","^:",20,"^7H",["^1A",[["^7A","^7Z"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^;3",["^7A","^7Z"],"Warning! Does not perform any validation or data conversion. Only change schema in a compatible way",["^ ","^7M",[["^1A",["^7N","^7A"]]]],["^1A",["^85",["^W",["^1A",["^7R","^7A","~$db/with-schema","^7Z"]]],"^W"]]]]],"^7E",false,"^7",659,"^8F",["^H",[null,"^7V"]],"^9",659,"^7G",2,"^7W",true,"^74",["^1A",["^75",["^1A",[["^7A","^7Z"]]]]]],"~$transact",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",743,"^8",7,"^9",743,"^:",15,"^74",["^1A",["^75",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]]]],"^78","Same as [[transact!]], but returns an immediately realized future.\n  \n   Exists for Datomic API compatibility. Prefer using [[transact!]] if possible.","^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^7I",["^1A",[null,null]]]],"^J","^3C","^6","datascript/core.cljc","^:",15,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^7I",["^1A",[null,null]]],"^7H",[["^7A","^9R"],["^7A","^9R","^9S"]],"^7J",null,"^7F",3,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^;5","Same as [[transact!]], but returns an immediately realized future.\n  \n   Exists for Datomic API compatibility. Prefer using [[transact!]] if possible.",["^1A",[["^7A","^9R"],["^1A",["^;5","^7A","^9R",null]]]],["^1A",[["^7A","^9R","^9S"],["^ ","^7M",[["^1A",["^7N","^7A"]]]],["^1A",["^85",["^86",["^1A",["^9T","^7A","^9R","^9S"]]],["^1A",["^8<","^8=",["^1A",["^8>",["~$_"],"^86"]],"^8@",["^1A",["^8A",["~$_","~$_","~$_"],"^86"]],"^8D",["^1A",["^8E",["~$_"],true]]]]]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U","^7V"],["^ ","^7F",3,"^7E",false,"^7U","^2P"]],"^7",743,"^9",743,"^7G",3,"^7W",true,"^74",["^1A",[["^7A","^9R"],["^7A","^9R","^9S"]]],"^78","Same as [[transact!]], but returns an immediately realized future.\n  \n   Exists for Datomic API compatibility. Prefer using [[transact!]] if possible."],"~$seek-datoms",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",380,"^8",7,"^9",380,"^:",18,"^74",["^1A",["^75",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]]]],"^78","Similar to [[datoms]], but will return datoms starting from specified components and including rest of the database until the end of the index.\n\n   If no datom matches passed arguments exactly, iterator will start from first datom that could be considered “greater” in index order.\n\n   Usage:\n\n       (seek-datoms db :eavt 1)\n       ; => (#datascript/Datom [1 :friends 2]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [1 :name \"Ivan\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n\n       (seek-datoms db :eavt 1 :name)\n       ; => (#datascript/Datom [1 :name \"Ivan\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       (seek-datoms db :eavt 2) \n       ; => (#datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; no datom [2 :likes \"fish\"], so starts with one immediately following such in index\n       (seek-datoms db :eavt 2 :likes \"fish\")\n       ; => (#datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])","^7D",["^ ","^7E",false,"^7F",6,"^7G",6,"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^7I",["^1A",[null,null,null,null,null]]]],"^J","^3A","^6","datascript/core.cljc","^:",18,"^7D",["^ ","^7E",false,"^7F",6,"^7G",6,"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^7I",["^1A",[null,null,null,null,null]]],"^7H",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]],"^7J",null,"^7F",6,"^7I",["^1A",[null,null,null,null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^;6","Similar to [[datoms]], but will return datoms starting from specified components and including rest of the database until the end of the index.\n\n   If no datom matches passed arguments exactly, iterator will start from first datom that could be considered “greater” in index order.\n\n   Usage:\n\n       (seek-datoms db :eavt 1)\n       ; => (#datascript/Datom [1 :friends 2]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [1 :name \"Ivan\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n\n       (seek-datoms db :eavt 1 :name)\n       ; => (#datascript/Datom [1 :name \"Ivan\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       (seek-datoms db :eavt 2) \n       ; => (#datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; no datom [2 :likes \"fish\"], so starts with one immediately following such in index\n       (seek-datoms db :eavt 2 :likes \"fish\")\n       ; => (#datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])",["^1A",[["^W","^8S"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["~$db/-seek-datoms","^W","^8S",null,null,null,null]]]],["^1A",[["^W","^8S","^8T"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^;7","^W","^8S","^8T",null,null,null]]]],["^1A",[["^W","^8S","^8T","^8U"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^;7","^W","^8S","^8T","^8U",null,null]]]],["^1A",[["^W","^8S","^8T","^8U","^8V"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^;7","^W","^8S","^8T","^8U","^8V",null]]]],["^1A",[["^W","^8S","^8T","^8U","^8V","^8W"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^;7","^W","^8S","^8T","^8U","^8V","^8W"]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U","^7V"],["^ ","^7F",3,"^7E",false,"^7U","^7V"],["^ ","^7F",4,"^7E",false,"^7U","^7V"],["^ ","^7F",5,"^7E",false,"^7U","^7V"],["^ ","^7F",6,"^7E",false,"^7U","^7V"]],"^7",380,"^9",380,"^7G",6,"^7W",true,"^74",["^1A",[["^W","^8S"],["^W","^8S","^8T"],["^W","^8S","^8T","^8U"],["^W","^8S","^8T","^8U","^8V"],["^W","^8S","^8T","^8U","^8V","^8W"]]],"^78","Similar to [[datoms]], but will return datoms starting from specified components and including rest of the database until the end of the index.\n\n   If no datom matches passed arguments exactly, iterator will start from first datom that could be considered “greater” in index order.\n\n   Usage:\n\n       (seek-datoms db :eavt 1)\n       ; => (#datascript/Datom [1 :friends 2]\n       ;     #datascript/Datom [1 :likes \"fries\"]\n       ;     #datascript/Datom [1 :likes \"pizza\"]\n       ;     #datascript/Datom [1 :name \"Ivan\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n\n       (seek-datoms db :eavt 1 :name)\n       ; => (#datascript/Datom [1 :name \"Ivan\"]\n       ;     #datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       (seek-datoms db :eavt 2) \n       ; => (#datascript/Datom [2 :likes \"candy\"]\n       ;     #datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])\n  \n       ; no datom [2 :likes \"fish\"], so starts with one immediately following such in index\n       (seek-datoms db :eavt 2 :likes \"fish\")\n       ; => (#datascript/Datom [2 :likes \"pie\"]\n       ;     #datascript/Datom [2 :likes \"pizza\"])"],"^I",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",252,"^8",7,"^9",252,"^:",13,"^74",["^1A",["^75",["^1A",[["^W","~$pred"]]]]],"^78","Returns a view over database that has same interface but only includes datoms for which the `(pred db datom)` is true. Can be applied multiple times.\n   \n   Filtered DB gotchas:\n\n   - All operations on filtered database are proxied to original DB, then filter pred is applied.\n   - Not cached. You pay filter penalty every time.\n   - Supports entities, pull, queries, index access.\n   - Does not support [[with]] and [[db-with]]."],"^J","^1Z","^6","datascript/core.cljc","^:",13,"^7H",["^1A",[["^W","^;8"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^I","Returns a view over database that has same interface but only includes datoms for which the `(pred db datom)` is true. Can be applied multiple times.\n   \n   Filtered DB gotchas:\n\n   - All operations on filtered database are proxied to original DB, then filter pred is applied.\n   - Not cached. You pay filter penalty every time.\n   - Supports entities, pull, queries, index access.\n   - Does not support [[with]] and [[db-with]].",["^W","^;8"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^8C",["^1A",["^91","^W"]],["^1A",["^85",["~$fdb","^W","~$orig-pred",["^1A",["~$.-pred","^;9"]],"~$orig-db",["^1A",["~$.-unfiltered-db","^;9"]]],["^1A",["~$FilteredDB.","^;<",["^1A",["^89",["~$p1__23683#"],["^1A",["~$and",["^1A",["^;:","^;?"]],["^1A",["^;8","^;<","^;?"]]]]]],["^1A",["^87",0]]]]]],["^1A",["^;>","^W",["^1A",["^89",["~$p1__23684#"],["^1A",["^;8","^W","^;A"]]]],["^1A",["^87",0]]]]]]]]],"^7E",false,"^7",252,"^8F","^3:","^9",252,"^7G",2,"^7W",true,"^74",["^1A",["^75",["^1A",[["^W","^;8"]]]]],"^78","Returns a view over database that has same interface but only includes datoms for which the `(pred db datom)` is true. Can be applied multiple times.\n   \n   Filtered DB gotchas:\n\n   - All operations on filtered database are proxied to original DB, then filter pred is applied.\n   - Not cached. You pay filter penalty every time.\n   - Supports entities, pull, queries, index access.\n   - Does not support [[with]] and [[db-with]]."],"~$last-tempid",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",713,"^8",16,"^9",713,"^:",27,"^83",true],"^83",true,"^J","^1[","^6","datascript/core.cljc","^:",27,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^;B",["^1A",["^87",-1000000]]]]],"^7",713,"^9",713,"^7U","^44"],"~$db-with",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",282,"^8",11,"^9",282,"^:",18,"^7U","^1=","^74",["^1A",["^75",["^1A",[["^W","^9R"]]]]],"^78","Applies transaction to an immutable db value, returning new immutable db value. Same as `(:db-after (with db tx-data))`."],"^J","^3F","^6","datascript/core.cljc","^:",18,"^7H",["^1A",[["^W","^9R"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^;C","Applies transaction to an immutable db value, returning new immutable db value. Same as `(:db-after (with db tx-data))`.",["^W","^9R"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["~:db-after",["^1A",["~$with","^W","^9R"]]]]]]],"^7E",false,"^7",282,"^8F","^1=","^9",282,"^7G",2,"^7U","^1=","^7W",true,"^74",["^1A",["^75",["^1A",[["^W","^9R"]]]]],"^78","Applies transaction to an immutable db value, returning new immutable db value. Same as `(:db-after (with db tx-data))`."],"^7N",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",456,"^8",7,"^9",456,"^:",12,"^74",["^1A",["^75",["^1A",[["^7A"]]]]],"^78","Returns `true` if this is a connection to a DataScript db, `false` otherwise."],"^J","^3G","^6","datascript/core.cljc","^:",12,"^7H",["^1A",[["^7A"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^7N","Returns `true` if this is a connection to a DataScript db, `false` otherwise.",["^7A"],["^1A",["^;@",["^1A",["~$satisfies?","^42","^7A"]],["^1A",["^8J",["^1A",["^8?","^7A"]]]]]]]]],"^7E",false,"^7",456,"^8F","^8R","^9",456,"^7G",1,"^7W",true,"^74",["^1A",["^75",["^1A",[["^7A"]]]]],"^78","Returns `true` if this is a connection to a DataScript db, `false` otherwise."],"~$unlisten!",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",689,"^8",7,"^9",689,"^:",16,"^74",["^1A",["^75",["^1A",[["^7A","^7C"]]]]],"^78","Removes registered listener from connection. See also [[listen!]]."],"^J","^3E","^6","datascript/core.cljc","^:",16,"^7H",["^1A",[["^7A","^7C"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^;G","Removes registered listener from connection. See also [[listen!]].",["^7A","^7C"],["^ ","^7M",[["^1A",["^7N","^7A"]],["^1A",["^7O",["^1A",["^7P",["^1A",["^7Q","^7A"]]]]]]]],["^1A",["^7R",["^1A",["^7P",["^1A",["^7Q","^7A"]]]],"~$dissoc","^7C"]]]]],"^7E",false,"^7",689,"^8F",["^H",[null,"^7V"]],"^9",689,"^7G",2,"^7W",true,"^74",["^1A",["^75",["^1A",[["^7A","^7C"]]]]],"^78","Removes registered listener from connection. See also [[listen!]]."],"~$->t_datascript$core23848",["^ ","^7@",null,"^5",["^ ","^:?",true,"^:9",["^H",["^::","^:;","^:<","^42","^:="]],"^:H",["^H",["^::","^:;","^:<","^42","^:="]],"^;1","^;2","^74",["^1A",["^75",["^1A",[["^7A","^9R","^9S","^86","^:M"]]]]],"^78","Positional factory function for datascript.core/t_datascript$core23848.","^6",null],"^:9",["^H",["^::","^:;","^:<","^42","^:="]],"^J","^3D","^6","datascript/core.cljc","^7H",["^1A",[["^7A","^9R","^9S","^86","^:M"]]],"^7J",null,"^7I",["^1A",[null,null]],"^:?",true,"^8",null,"^79",["^ ","^7:","^7;","^7<",["^1A",["^:@","^:L",["^7A","^9R","^9S","^86","^:M"],"^:=",["^1A",["^:B",["^:N","^:M"],["^1A",["^:D","^:L","^7A","^9R","^9S","^86","^:M"]]]],"^:<",["^1A",["^:E",["^:N"],"^:M"]],"^8=",["^1A",["^8>",["~$_"],"^86"]],"^8@",["^1A",["^8A",["~$_","~$_","~$_"],"^86"]],"^8D",["^1A",["^8E",["~$_"],true]]]]],"^7E",false,"^;1","^;2","^7",null,"^8F","^2P","^7G",5,"^7W",true,"^74",["^1A",["^75",["^1A",[["^7A","^9R","^9S","^86","^:M"]]]]],"^:H",["^H",["^::","^:;","^:<","^42","^:="]],"^78","Positional factory function for datascript.core/t_datascript$core23848."],"^;E",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",273,"^8",7,"^9",273,"^:",11,"^74",["^1A",["^75",["^1A",[["^W","^9R"],["^W","^9R","^9S"]]]]],"^78","Same as [[transact!]], but applies to an immutable database value. Returns transaction report (see [[transact!]]).","^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^W","^9R"],["^W","^9R","^9S"]],"^74",["^1A",[["^W","^9R"],["^W","^9R","^9S"]]],"^7I",["^1A",[null,null]]]],"^J","^23","^6","datascript/core.cljc","^:",11,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^W","^9R"],["^W","^9R","^9S"]],"^74",["^1A",[["^W","^9R"],["^W","^9R","^9S"]]],"^7I",["^1A",[null,null]]],"^7H",[["^W","^9R"],["^W","^9R","^9S"]],"^7J",null,"^7F",3,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^;E","Same as [[transact!]], but applies to an immutable database value. Returns transaction report (see [[transact!]]).",["^1A",[["^W","^9R"],["^1A",["^;E","^W","^9R",null]]]],["^1A",[["^W","^9R","^9S"],["^ ","^7M",[["^1A",["^8J","^W"]]]],["^1A",["^8C",["^1A",["^91","^W"]],["^1A",["~$throw",["^1A",["~$ex-info","Filtered DB cannot be modified",["^ ","~:error","~:transaction/filtered"]]]]],["^1A",["~$db/transact-tx-data",["^1A",["~$db/->TxReport","^W","^W",[],["^ "],"^9S"]],"^9R"]]]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U","^7V"],["^ ","^7F",3,"^7E",false,"^7U",["^H",["~$clj","^7V"]]]],"^7",273,"^9",273,"^7G",3,"^7W",true,"^74",["^1A",[["^W","^9R"],["^W","^9R","^9S"]]],"^78","Same as [[transact!]], but applies to an immutable database value. Returns transaction report (see [[transact!]])."],"~$touch",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",99,"^8",3,"^9",99,"^:",8,"^7U","^8H","^74",["^1A",["^75",["^1A",[["~$e"]]]]],"^78","Forces all entity attributes to be eagerly fetched and cached. Only usable for debug output.\n\n             Usage:\n\n             ```\n             (entity db 1) ; => {:db/id 1}\n             (touch (entity db 1)) ; => {:db/id 1, :dislikes [:pie], :likes [:pizza]}\n             ```"],"^J","^3N","^6","datascript/core.cljc","^:",8,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^;Q","~$de/touch"]]],"^7",89,"^9",99,"^7U","^8H","^74",["^1A",["^75",["^1A",[["~$e"]]]]],"^78","Forces all entity attributes to be eagerly fetched and cached. Only usable for debug output.\n\n             Usage:\n\n             ```\n             (entity db 1) ; => {:db/id 1}\n             (touch (entity db 1)) ; => {:db/id 1, :dislikes [:pie], :likes [:pizza]}\n             ```"],"~$with-schema",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",288,"^8",11,"^9",288,"^:",22,"^7U","^1=","^74",["^1A",["^75",["^1A",[["^W","^7Z"]]]]],"^78","Warning! No validation or conversion. Only change schema in a compatible way"],"^J","^3K","^6","datascript/core.cljc","^:",22,"^7H",["^1A",[["^W","^7Z"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^;S","Warning! No validation or conversion. Only change schema in a compatible way",["^W","^7Z"],["^1A",["^;4","^W","^7Z"]]]]],"^7E",false,"^7",288,"^8F","^1=","^9",288,"^7G",2,"^7U","^1=","^7W",true,"^74",["^1A",["^75",["^1A",[["^W","^7Z"]]]]],"^78","Warning! No validation or conversion. Only change schema in a compatible way"],"~$reset-conn!",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",634,"^8",7,"^9",634,"^:",18,"^74",["^1A",["^75",["^1A",[["^7A","^W"],["^7A","^W","^9S"]]]]],"^78","Forces underlying `conn` value to become `db`. Will generate a tx-report that will remove everything from old value and insert everything from the new one.","^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^W"],["^7A","^W","^9S"]],"^74",["^1A",[["^7A","^W"],["^7A","^W","^9S"]]],"^7I",["^1A",[null,null]]]],"^J","^26","^6","datascript/core.cljc","^:",18,"^7D",["^ ","^7E",false,"^7F",3,"^7G",3,"^7H",[["^7A","^W"],["^7A","^W","^9S"]],"^74",["^1A",[["^7A","^W"],["^7A","^W","^9S"]]],"^7I",["^1A",[null,null]]],"^7H",[["^7A","^W"],["^7A","^W","^9S"]],"^7J",null,"^7F",3,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^;T","Forces underlying `conn` value to become `db`. Will generate a tx-report that will remove everything from old value and insert everything from the new one.",["^1A",[["^7A","^W"],["^1A",["^;T","^7A","^W",null]]]],["^1A",[["^7A","^W","^9S"],["^ ","^7M",[["^1A",["^7N","^7A"]],["^1A",["^8J","^W"]]]],["^1A",["^85",["~$db-before",["^1A",["^8?","^7A"]],"^:W",["^1A",["~$db/map->TxReport",["^ ","~:db-before","^;U","^;D","^W","~:tx-data",["^1A",["~$concat",["^1A",["~$map",["^1A",["^89",["~$p1__23792#"],["^1A",["^7S","^;[","~:added",false]]]],["^1A",["^7Y","^;U","^:K"]]]],["^1A",["^7Y","^W","^:K"]]]],"~:tx-meta","^9S"]]]],["^1A",["^8;","^7A","^W"]],["^1A",["^:Y",[["~$_","^7B"],["^1A",["^:Z",["^1A",["^7P",["^1A",["^7Q","^7A"]]]],["^1A",["^:["]]]]],["^1A",["^7B","^:W"]]]],"^W"]]]]]]],"^7E",false,"^7T",[["^ ","^7F",2,"^7E",false,"^7U","^7V"],["^ ","^7F",3,"^7E",false]],"^7",634,"^9",634,"^7G",3,"^7W",true,"^74",["^1A",[["^7A","^W"],["^7A","^W","^9S"]]],"^78","Forces underlying `conn` value to become `db`. Will generate a tx-report that will remove everything from old value and insert everything from the new one."],"^9B",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",224,"^8",3,"^9",224,"^:",15,"^74",["^1A",["^75",["^1A",[["^W"],["^W","^7["]]]]],"^78","Converts db into a data structure (not string!) that can be fed to serializer\n             of your choice (e.g. `js/JSON.stringify` in CLJS, `cheshire.core/generate-string`\n             or `jsonista.core/write-value-as-string` in CLJ).\n\n             On JVM, `serializable` holds a global lock that prevents any two serializations\n             to run in parallel (an implementation constraint, be aware).\n\n             Options:\n\n             `:freeze-fn` Non-primitive values will be serialized using this. Optional.\n             `pr-str` by default."],"^J","^3L","^6","datascript/core.cljc","^:",15,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^9B","~$ds/serializable"]]],"^7",212,"^9",224,"^74",["^1A",["^75",["^1A",[["^W"],["^W","^7["]]]]],"^78","Converts db into a data structure (not string!) that can be fed to serializer\n             of your choice (e.g. `js/JSON.stringify` in CLJS, `cheshire.core/generate-string`\n             or `jsonista.core/write-value-as-string` in CLJ).\n\n             On JVM, `serializable` holds a global lock that prevents any two serializations\n             to run in parallel (an implementation constraint, be aware).\n\n             Options:\n\n             `:freeze-fn` Non-primitive values will be serialized using this. Optional.\n             `pr-str` by default."],"~$entid",["^ ","^5",["^ ","^6","datascript/core.cljc","^7",81,"^8",3,"^9",81,"^:",8,"^74",["^1A",["^75",["^1A",[["^W","^77"]]]]],"^78","Given lookup ref `[unique-attr value]`, returns numberic entity id.\n\n             If entity does not exist, returns `nil`."],"^J","^3P","^6","datascript/core.cljc","^:",8,"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7=","^<3","~$db/entid"]]],"^7",77,"^9",81,"^7U","^:3","^74",["^1A",["^75",["^1A",[["^W","^77"]]]]],"^78","Given lookup ref `[unique-attr value]`, returns numberic entity id.\n\n             If entity does not exist, returns `nil`."],"^:R",["^ ","^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",715,"^8",7,"^9",715,"^:",13,"^74",["^1A",["^75",["^1A",[["~$part"],["^<5","~$x"]]]]],"^78","Allocates and returns an unique temporary id (a negative integer). Ignores `part`. Returns `x` if it is specified.\n  \n   Exists for Datomic API compatibility. Prefer using negative integers directly if possible.","^7D",["^ ","^7E",false,"^7F",2,"^7G",2,"^7H",[["^<5"],["^<5","~$x"]],"^74",["^1A",[["^<5"],["^<5","~$x"]]],"^7I",["^1A",[null,null]]]],"^J","^2:","^6","datascript/core.cljc","^:",13,"^7D",["^ ","^7E",false,"^7F",2,"^7G",2,"^7H",[["^<5"],["^<5","~$x"]],"^74",["^1A",[["^<5"],["^<5","~$x"]]],"^7I",["^1A",[null,null]]],"^7H",[["^<5"],["^<5","~$x"]],"^7J",null,"^7F",2,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^:R","Allocates and returns an unique temporary id (a negative integer). Ignores `part`. Returns `x` if it is specified.\n  \n   Exists for Datomic API compatibility. Prefer using negative integers directly if possible.",["^1A",[["^<5"],["^1A",["^8C",["^1A",["~$=","^<5","~:db.part/tx"]],"~:db/current-tx",["^1A",["^7R","^;B","~$dec"]]]]]],["^1A",[["^<5","~$x"],["^1A",["^8C",["^1A",["~$=","^<5","^<6"]],"^<7","~$x"]]]]]]],"^7E",false,"^7T",[["^ ","^7F",1,"^7E",false,"^7U",["^H",[null,"^7V","~$cljs.core/Keyword"]]],["^ ","^7F",2,"^7E",false,"^7U",["^H",[null,"^<9"]]]],"^7",715,"^9",715,"^7G",2,"^7W",true,"^74",["^1A",[["^<5"],["^<5","~$x"]]],"^78","Allocates and returns an unique temporary id (a negative integer). Ignores `part`. Returns `x` if it is specified.\n  \n   Exists for Datomic API compatibility. Prefer using negative integers directly if possible."],"^:X",["^ ","^:0",true,"^7@",null,"^5",["^ ","^6","datascript/core.cljc","^7",516,"^8",16,"^9",516,"^:",26,"^:0",true,"^74",["^1A",["^75",["^1A",[["^7A","^9R","^9S"]]]]]],"^J","^41","^6","datascript/core.cljc","^:",26,"^7H",["^1A",[["^7A","^9R","^9S"]]],"^7J",null,"^7I",["^1A",[null,null]],"^8",1,"^79",["^ ","^7:","^7;","^7<",["^1A",["^7K","^:X",["^7A","^9R","^9S"],["^ ","^7M",[["^1A",["^7N","^7A"]]]],["^1A",["^85",["~$*report",["^1A",["^87",null]]],["^1A",["^7R","^7A",["^1A",["~$fn",["^W"],["^1A",["^85",["~$r",["^1A",["^;E","^W","^9R","^9S"]]],["^1A",["^8;","^<:","~$r"]],["^1A",["^;D","~$r"]]]]]]]],["^1A",["^8?","^<:"]]]]]]],"^7E",false,"^7",516,"^8F","^7V","^9",516,"^7G",3,"^7W",true,"^74",["^1A",["^75",["^1A",[["^7A","^9R","^9S"]]]]]]],"^1?",["^ ","^U","^U","^W","^X","^10","^11","^11","^11","^X","^X","^16","^16","^17","^16"],"~:cljs.analyzer/constants",["^ ","^19",["^H",["^86","^9S","^8O","^:M","^5","^8N","^7M","^7A","^;D","^<0","^88","^;M","^:A","^:K","^9V","^;W","^;X","^<6","^<7","^9X","^;L","^9R","^<1","^7P","~$f"]],"~:order",["^;L","^;M","^;D","^5","^7P","^8N","^8O","^;W","^;X","^<1","^<0","^:K","^7M","^9V","^9X","^<6","^<7","^7A","^9R","^9S","^86","^:M","~$f","^88","^:A"]],"^1G",["^ ","^1:",["^H",[]]],"^1H",["^ "],"^1I",["^V","^U","^16","^X","^12","^11","^Z","^S","^14","^T","^R"]],"^N","^K","~:ns-specs",["^ "],"~:ns-spec-vars",["^H",[]],"~:compiler-options",["^4J",[["^<@","~:static-fns"],true,["~:js-options","~:use-babel"],null,["^<@","~:shadow-tweaks"],null,["^<@","~:source-map-inline"],null,["^<@","~:elide-asserts"],false,["^<@","~:optimize-constants"],null,["^<@","^1N"],null,["^<@","~:external-config"],null,["^<@","~:tooling-config"],null,["^<@","~:emit-constants"],null,["^<@","~:load-tests"],null,["^<@","~:form-size-threshold"],null,["^<@","~:global-goog-object&array"],null,["^<@","~:data-readers"],null,["^<@","~:infer-externs"],"~:auto",["^<@","^1P"],null,["^<B","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^<@","~:fn-invoke-direct"],null,["^<@","~:source-map"],"/dev/null"]]]